--- a/net/minecraft/client/renderer/EntityRenderer.java
+++ b/net/minecraft/client/renderer/EntityRenderer.java
@@ -3,14 +3,28 @@
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.gson.JsonSyntaxException;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.provider.OpenVRPlayer;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.Utils;
+
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.EulerOrient;
+
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
 import java.awt.image.ImageObserver;
 import java.io.File;
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.Callable;
+
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import net.minecraft.block.Block;
@@ -18,11 +32,17 @@
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.AbstractClientPlayer;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.gui.Gui;
+import net.minecraft.client.gui.GuiMainMenu;
+import net.minecraft.client.gui.GuiWinGame;
 import net.minecraft.client.gui.MapItemRenderer;
 import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.particle.ParticleManager;
+import net.minecraft.client.renderer.GlStateManager.Color;
 import net.minecraft.client.renderer.culling.ClippingHelperImpl;
 import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.client.renderer.culling.ICamera;
@@ -46,9 +66,11 @@
 import net.minecraft.entity.passive.EntityAnimal;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
 import net.minecraft.init.MobEffects;
 import net.minecraft.init.SoundEvents;
 import net.minecraft.inventory.IInventory;
+import net.minecraft.item.ItemBow;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EntitySelectors;
@@ -63,14 +85,21 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.DimensionType;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
 import net.minecraft.world.biome.Biome;
+import paulscode.sound.SoundSystem;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.Project;
 
@@ -84,6 +113,50 @@
     /** Anaglyph field (0=R, 1=GB) */
     public static int anaglyphField;
 
+	/** MINECRIFT */
+	public static final float MAX_CROSSHAIR_DISTANCE = 64f;
+	public int renderpass = 0;
+	public EulerOrient currentEulerOrientDegrees = new EulerOrient();
+	public boolean sndSystemReflect = true;
+	public boolean guiYawOrientationResetRequested = false;
+	public boolean hudShowingLastFrame = false; //Used for detecting when UI is shown, fixing the guiYaw
+	public boolean guiScreenShowingThisFrame = false;
+	public float hudHeadYaw = 0.0f; //Not including mouse
+	public boolean inGameMenuShowingLastFrame = false;
+	public boolean inWorldGuiScreenShowingThisFrame = false;
+	public float inGameMenuHeadYaw = 0.0f; //Not including mouse
+	public Vec3d interpolatedPlayerPos = new Vec3d(0, 0, 0);
+	public double cameraRoll;
+	public float headYaw = 0.0F; //relative to head tracker reference frame, absolute
+	public float headPitch = 0.0F;
+	public float headRoll = 0.0F;
+	public float prevHeadYaw = 0.0F;
+	public float prevHeadPitch = 0.0F;
+	public float prevHeadRoll = 0.0F;
+
+	public float crossX;
+	public float crossY;
+	public float crossZ;
+
+	public FloatBuffer[] eyeproj = new FloatBuffer[2]; //i dislike you.
+	
+	private boolean eyeCollision = false;
+	Block eyeCollisionBlock;
+	Vec3d eyeCollisionBlockPosLoc;
+	public float headCollisionThresholdDistance = 0.05f;
+	public float headCollisionDistance = -1f;
+	public Field _soundManagerSndSystemField = null;
+	public float clipDistance = 0f;
+	public float minClipDistance = 0.05f;
+	public boolean trySoundSystemReflect = true;
+	public float lookYawOffset = 0;
+	public float lookPitchOffset = 0;
+	public int callCount = 0;
+	public boolean warningsEnabled = false;
+	private Vec3d centerEyePosToCrossDirection;
+	public Vec3d crossVec;
+	/** END MINECRIFT */
+    
     /** A reference to the Minecraft object. */
     private final Minecraft mc;
     private final IResourceManager resourceManager;
@@ -2085,4 +2158,1833 @@
         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
         GlStateManager.popMatrix();
     }
+    
+    //VIVECRAFT ADDITIONS *********************************************************
+	public void setupClipPlanes()
+	{
+		this.farPlaneDistance = (float)(mc.gameSettings.renderDistanceChunks * 16);
+
+//		if (Config.isFogFancy())
+//		{
+//			this.farPlaneDistance *= 0.95F;
+//		}
+//
+//		if (Config.isFogFast())
+//		{
+//			this.farPlaneDistance *= 0.83F;
+//		}
+
+		this.clipDistance = this.farPlaneDistance * 2.0F;
+
+		if (this.clipDistance < 128.0F)
+		{
+			this.clipDistance = 128.0F;
+		}
+
+		if (mc.theWorld != null && mc.theWorld.provider != null && mc.theWorld.provider.getDimensionType() == DimensionType.THE_END)
+		{
+			this.clipDistance = 256.0F;
+		}
+	}
+    
+
+	private void updateMainMenu(GuiMainMenu mainGui)
+	{
+		try
+		{
+			String e = null;
+			Calendar calendar = Calendar.getInstance();
+			calendar.setTime(new Date());
+			int day = calendar.get(5);
+			int month = calendar.get(2) + 1;
+
+			if (day == 8 && month == 4)
+			{
+				e = "Happy birthday, OptiFine!";
+			}
+
+			if (day == 14 && month == 8)
+			{
+				e = "Happy birthday, sp614x!";
+			}
+
+			if (e == null)
+			{
+				return;
+			}
+
+			Field[] fs = GuiMainMenu.class.getDeclaredFields();
+
+			for (int i = 0; i < fs.length; ++i)
+			{
+				if (fs[i].getType() == String.class)
+				{
+					fs[i].setAccessible(true);
+					fs[i].set(mainGui, e);
+					break;
+				}
+			}
+		}
+		catch (Throwable var8)
+		{
+			;
+		}
+	}
+
+	/** MINECRIFT ADDITIONS BELOW **/
+
+	public void updatePositionAndOrientation( float renderPartialTicks, boolean displayActive )
+	{
+		//int millis = (int)(System.currentTimeMillis() - start);
+		//System.out.println("Update camera! " + millis + "ms");
+
+		EulerOrient o = mc.vrPlayer.getHMDEuler_World();
+
+		cameraYaw    = o.yaw;
+		cameraPitch  = o.pitch;
+		cameraRoll   = o.roll;
+
+		if (this.mc.vrSettings.debugPose)
+		{
+			System.out.println(String.format("headYaw:   %.2f, headPitch:   %.2f, headRoll:   %.2f", new Object[] {Float.valueOf(headYaw), Float.valueOf(headPitch), Float.valueOf(headRoll)}));
+			System.out.println(String.format("cameraYaw: %.2f, cameraPitch: %.2f, cameraRoll: %.2f", new Object[] {Float.valueOf((float)cameraYaw), Float.valueOf((float)cameraPitch), Float.valueOf((float)cameraRoll)}));
+		}
+
+
+		float PIOVER180 = (float)(Math.PI/180);
+		EntityPlayer entity = this.mc.thePlayer;
+
+		if( entity != null )
+		{		//now we decide what direction vector to set our 'entity' at.
+			//This is used for all sorts of things both client and server side.
+
+			if(false){  //hmm, to use HMD?
+				//set model view direction to camera
+				entity.rotationYaw = (float)cameraYaw;
+				entity.rotationPitch = (float)cameraPitch;
+			} else { //default to looking 'at' the crosshair position.
+				if(centerEyePosToCrossDirection != null){
+					float pitch = - (float)Math.toDegrees(Math.asin(centerEyePosToCrossDirection.yCoord/centerEyePosToCrossDirection.lengthVector()));
+					float yaw = - (float)Math.toDegrees(Math.atan2(centerEyePosToCrossDirection.xCoord, centerEyePosToCrossDirection.zCoord));    
+					entity.rotationYaw = yaw;
+					entity.rotationPitch = pitch;
+				}
+			}
+
+			if(entity instanceof EntityPlayerSP){ //isnt it always?
+
+				if(entity.moveForward > 0 && (mc.vrPlayer.getFreeMoveMode() || entity.isRiding())){
+					//us laim, needed for server side movement.
+					entity.rotationYaw =  -mc.roomScale.getControllerOffhandYaw_World();
+					entity.rotationPitch = -mc.roomScale.getControllerOffhandPitch_World();
+				} else {
+					ItemStack i = ((EntityPlayerSP) entity).inventory.getCurrentItem();
+					if(i !=null){
+						if(i.getItem() instanceof ItemBow){
+							//use bow aim
+							Vec3d aim = mc.bowTracker.getAimVector();
+
+							float pitch = -(float)Math.toDegrees(Math.asin(aim.yCoord/aim.lengthVector()));
+							float yaw = -(float)Math.toDegrees(Math.atan2(aim.xCoord, aim.zCoord));   		
+
+							entity.rotationYaw =  (float)yaw;
+							entity.rotationPitch = (float)pitch;
+
+						}	 else if(i.getItem() == Items.snowball ||
+								i.getItem() == Items.egg  ||
+								i.getItem() == Items.spawn_egg  ||
+								i.getItem() == Items.potionitem  
+								) {
+							//use r_hand aim
+							entity.rotationYaw =  -mc.roomScale.getControllerMainYaw_World();
+							entity.rotationPitch = -mc.roomScale.getControllerMainPitch_World();
+						}
+					}
+				}
+			}
+		}
+
+	
+	}
+
+	private float checkCameraCollision(
+			double camX,       double camY,       double camZ,
+			double camXOffset, double camYOffset, double camZOffset, float distance )
+	{
+		//This loop offsets at [-.1, -.1, -.1], [.1,-.1,-.1], [.1,.1,-.1] etc... for all 8 directions
+		double minDistance = -1d;
+
+		// Lets extend out the test range somewhat
+		camXOffset *= 10f;
+		camYOffset *= 10f;
+		camZOffset *= 10f;
+
+		for (int var20 = 0; var20 < 8; ++var20)
+		{
+			final float MIN_DISTANCE = 0.06F;
+			float var21 = (float)((var20 & 1) * 2 - 1);
+			float var22 = (float)((var20 >> 1 & 1) * 2 - 1);
+			float var23 = (float)((var20 >> 2 & 1) * 2 - 1);
+			var21 *= 0.1F;
+			var22 *= 0.1F;
+			var23 *= 0.1F;
+			RayTraceResult var24 = this.mc.theWorld.rayTraceBlocks(
+					new Vec3d(camX + var21, camY + var22, camZ + var23),
+					new Vec3d(camX - camXOffset + var21, camY - camYOffset + var22, camZ - camZOffset + var23));
+
+			BlockPos bp = var24.getBlock();
+			if (var24 != null && this.mc.theWorld.isBlockNormalCubeDefault(bp.getX(), bp.getY(), bp.getZ(), true))
+			{
+				double var25 = var24.hitVec.distanceTo(new Vec3d(camX, camY, camZ)) - MIN_DISTANCE;
+
+				if (minDistance == -1d)
+				{
+					minDistance = var25;
+				}
+				else if (var25 < minDistance)
+				{
+					minDistance = var25;
+				}
+			}
+		}
+		if (minDistance == -1d)
+			minDistance = distance *= 10d;
+
+		return (float)minDistance;
+	}
+
+	public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+	{
+		float aspect = displayHeight / displayWidth;
+
+		GL11.glBegin(GL11.GL_QUADS);
+
+		GL11.glTexCoord2f(0.0f, 0.0f);
+		GL11.glVertex3f(-(size / 2f), -(size * aspect) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f);
+		GL11.glVertex3f(size / 2f, -(size * aspect) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f);
+		GL11.glVertex3f(size / 2f, (size * aspect) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f);
+		GL11.glVertex3f(-(size / 2f), (size * aspect) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+
+
+	/**
+	 * Sets the listener of sounds
+	 */
+	public void setSoundListenerOrientation()
+	{
+//		SoundSystem sndSystem = null;
+//
+//		// Get the soundManager from mc.mcSoundHandler (sndManager or field_147694_f)
+//		// then get SoundSystem from it (sndSystem or field_148620_e)
+//		// Obfuscated names (from MCP908/conf/joined.srg):
+//		//    SoundHandler.sndManager = SoundHandler.field_147694_f = btp/a
+//		//    stem.sndSystem = SoundSySoundSystem.field_148620_e = btj/e
+//
+//		// Use reflection to get the sndManager
+//		if (sndSystemReflect && _soundManagerSndSystemField == null && this.trySoundSystemReflect)
+//		{
+//			try
+//			{
+//				// Get SoundManager from the SoundHandler...
+//				Field soundManagerField = Utils.getDeclaredField(mc.mcSoundHandler.getClass(), 
+//						"sndManager", 
+//						"f", 
+//						"field_147694_f");
+//				if (soundManagerField != null)
+//				{
+//					soundManagerField.setAccessible(true);
+//					this.mc.sndManager = (SoundManager) soundManagerField.get(mc.mcSoundHandler);
+//				}
+//
+//				// ...get SoundSystem from SoundManager
+//				if (this.mc.sndManager != null)
+//				{
+//					_soundManagerSndSystemField = Utils.getDeclaredField(this.mc.sndManager.getClass(),
+//							"sndSystem", 
+//							"e", 
+//							"field_148620_e");
+//					if (_soundManagerSndSystemField != null)
+//					{
+//						_soundManagerSndSystemField.setAccessible(true);
+//					}
+//				}
+//			}
+//			catch (IllegalAccessException e)
+//			{
+//				e.printStackTrace();
+//			}
+//
+//			if (_soundManagerSndSystemField == null) {
+//				this.trySoundSystemReflect = false;
+//				System.out.println("[Minecrift]: FAILED to reflect sndSystem");
+//			}
+//			else {
+//				System.out.println("[Minecrift]: Reflected sndSystem");
+//			}
+//		}
+//
+//		if (_soundManagerSndSystemField != null && this.mc.sndManager != null)
+//		{
+//			try
+//			{
+//				sndSystem = (SoundSystem)_soundManagerSndSystemField.get(this.mc.sndManager);
+//			}
+//			catch (IllegalArgumentException e) { }
+//			catch (IllegalAccessException e) { };
+//		}
+//
+//		float PIOVER180 = (float)(Math.PI/180);
+//
+//		// TODO: Set based on head orient (headphones) or body orient (speakers)
+//
+//		Vec3d up = new Vec3d(0, 1, 0);
+//		up.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+//		up.rotateAroundX(-(float)cameraPitch* PIOVER180);
+//		up.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+//		//synchronized (SoundSystemConfig.THREAD_SYNC) {
+//		if (/*SoundManger.soundLibrary != null &&*/ sndSystem != null /* && this.mc.gameSettings.getSoundVolume(SoundCategory // Which sound category?) != 0f // this.mc.gameSettings.soundVolume != 0f */)
+//		{
+//			// The sound system is on a separate thread? Sync issues? Can get to crash by turning analyglph mode on?
+//
+//			sndSystem.setListenerPosition((float) interpolatedPlayerPos.xCoord, (float) interpolatedPlayerPos.yCoord, (float) interpolatedPlayerPos.zCoord);
+//			Vec3d hmd = mc.roomScale.getHMDDir_World();
+//			sndSystem.setListenerOrientation((float)hmd.xCoord,(float) hmd.yCoord,(float) hmd.zCoord,
+//					(float) up.xCoord, (float) up.yCoord, (float) up.zCoord);
+//		}
+//		//}
+//		if( mc.mumbleLink != null ) {
+//			Vec3d forward = new Vec3d(0, 0 , -1);
+//			forward.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+//			forward.rotateAroundX(-(float)cameraPitch* PIOVER180);
+//			forward.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+//			mc.mumbleLink.updateMumble(
+//					(float)interpolatedPlayerPos.xCoord,  (float)interpolatedPlayerPos.yCoord,  (float)interpolatedPlayerPos.zCoord,
+//					(float)forward.xCoord, (float)forward.yCoord, (float)forward.zCoord,
+//					(float)up.xCoord,      (float)up.yCoord,      (float)up.zCoord);
+//		}
+	}
+
+	public void handleNotificationText()
+	{
+		String prefix = "";
+		String message = "";
+		String suffix = "";
+
+		boolean renderTxt = false;
+
+		// error info takes precedence
+		if (mc.errorHelper != null) {
+			if (System.currentTimeMillis() < mc.errorHelper.endTime)
+			{
+				prefix = mc.errorHelper.title;
+				message = mc.errorHelper.message;
+				suffix = mc.errorHelper.resolution;
+				renderTxt = true;
+			}
+			else
+			{
+				mc.errorHelper = null;
+			}
+		}
+		// otherwise display any calibration info
+		if (renderTxt)
+			displayNotificationText(prefix, message, suffix,
+					this.mc.displayWidth, this.mc.displayHeight, this.mc.stereoProvider.isStereo(), !this.mc.stereoProvider.isStereo());
+	}
+
+	public void displayNotificationText(String prefix, String message, String suffix,
+			int displayWidth, int displayHeight, boolean isStereo, boolean isGuiOrtho)
+	{
+		final float INITIAL_TEXT_SCALE = isGuiOrtho ? 0.0055f : 0.00375f;
+		final int TEXT_WORDWRAP_LEN = 55;
+		final int COLUMN_GAP = 12;
+
+		float fade = isGuiOrtho ? 0.85f : 0.80f;
+		Color rgb = new Color(0f, 0f, 0f, 1);
+	//	renderFadeBlend(rgb, fade);
+
+		// Pass matrici on to OpenGL...
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+			GL11.glLoadIdentity();
+			if (isStereo)
+			{
+				GL11.glMultMatrix(eyeproj[mc.currentEye.value()]);
+			}
+			else
+			{
+				Project.gluPerspective(90f, (float) displayWidth / (float) displayHeight, minClipDistance, clipDistance);
+			}
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+				GL11.glLoadIdentity();
+		
+				int column = 8;
+				ArrayList<String> wrapped = new ArrayList<String>();
+				if (message != null)
+					Utils.wordWrap(message, TEXT_WORDWRAP_LEN, wrapped);
+				float rows = wrapped.size();
+				float shift = rows / 2f;
+		
+				float x = isGuiOrtho ? 0f : -this.mc.vrSettings.getHalfIPD(this.mc.currentEye);
+				float y = shift * COLUMN_GAP * 0.003f; // Move up
+				float z = -0.6f;
+		
+				GL11.glDisable(GL11.GL_DEPTH_TEST);
+				GL11.glTranslatef(x, y, z);
+				GL11.glRotatef(180f, 0.0F, 1.0F, 0.0F);
+				float textScale = (float) Math.sqrt((x * x + y * y + z * z));
+				GL11.glScalef(-INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale);
+				if (prefix != null)
+					mc.fontRendererObj.drawStringWithShadow(prefix, -mc.fontRendererObj.getStringWidth(prefix) / 2, -8, /*white*/16777215);
+		
+				for (String line : wrapped)
+				{
+					mc.fontRendererObj.drawStringWithShadow(line, -mc.fontRendererObj.getStringWidth(line) / 2, column, /*white*/16777215);
+					column += COLUMN_GAP;
+				}
+				column += COLUMN_GAP;
+				if (suffix != null)
+					mc.fontRendererObj.drawStringWithShadow(suffix, -mc.fontRendererObj.getStringWidth(suffix) / 2, column, /*white*/16777215);
+		
+				GL11.glEnable(GL11.GL_DEPTH_TEST);
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+	}
+
+	// Thanks to mhagain
+	public void renderFadeBlend (Color rgb, float fadeAlpha, int left, int right, int bottom, int top)
+	{
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glDisable(GL11.GL_TEXTURE_2D);
+
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+
+		// when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+		// it is the direction i read in, after all.  live with it, weenies.
+		GL11.glOrtho(0, this.mc.displayWidth, this.mc.displayHeight, 0, -1, 1);
+
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+
+		GL11.glColor4f(rgb.r, rgb.g, rgb.b, fadeAlpha);
+
+		GL11.glBegin(GL11.GL_QUADS);
+
+		GL11.glVertex3f(left, top, 0);
+		GL11.glVertex3f(right, top, 0);
+		GL11.glVertex3f(right, bottom, 0);
+		GL11.glVertex3f(left, bottom, 0);
+
+		GL11.glEnd();
+
+		GL11.glDisable(GL11.GL_BLEND);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPopMatrix();
+
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+	}
+
+	public void getPointedBlock(float par1)
+	{
+		/** END MINECRIFT */    
+		if (this.mc.getRenderViewEntity() != null && this.mc.theWorld != null)
+		{
+			/** MINECRIFT */
+			// Lets choose to use the head position for block / entity distance hit / miss calcs for now. Lean
+			// forward, you can hit further away...
+	
+			this.mc.pointedEntity = null;
+			double blockReachDistance = mc.vrSettings.vrWorldScale * (double)this.mc.playerController.getBlockReachDistance();
+			double entityReachDistance = (double)this.mc.playerController.getBlockReachDistance();
+			// Darktemp's crosshair fix
+			// VIVE START - interact source	
+			
+			Vec3d aimsource = mc.roomScale.getControllerMainPos_World();
+			Vec3d aimsoucecopy = new Vec3d(aimsource.xCoord, aimsource.yCoord, aimsource.zCoord);
+			Vec3d aimsourcecopy2 = new Vec3d(aimsource.xCoord, aimsource.yCoord, aimsource.zCoord);
+			// VIVE END - interact source
+	
+			Vec3d aim = mc.roomScale.getControllerMainDir_World();
+			Vec3d endPos = aimsource.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+			crossVec=aimsource.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+	
+			this.mc.objectMouseOver = this.mc.theWorld.rayTraceBlocks(aimsource, endPos, false, false, true);
+			
+			//JRBUDDA - i dunno what any of this does that option isnt used.
+			
+			double maxreach = MAX_CROSSHAIR_DISTANCE;
+			
+			//   System.out.println(this.mc.objectMouseOver.toString());
+			if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit == Type.MISS)
+			{
+				// Get MISS distance
+				if (!this.mc.vrSettings.maxCrosshairDistanceAtBlockReach) {
+					endPos = aimsoucecopy.addVector(aim.xCoord * MAX_CROSSHAIR_DISTANCE, aim.yCoord * MAX_CROSSHAIR_DISTANCE, aim.zCoord * MAX_CROSSHAIR_DISTANCE);
+					RayTraceResult crossPos = this.mc.theWorld.rayTraceBlocks(aimsoucecopy, endPos, false, false, true);
+					if (crossPos != null) {
+						crossVec = crossPos.hitVec;
+						maxreach = crossVec.distanceTo(aimsourcecopy2);
+					} else {
+						crossVec = new Vec3d(endPos.xCoord, endPos.yCoord, endPos.zCoord);
+						maxreach = crossVec.distanceTo(aimsourcecopy2);
+					}
+				}
+				this.mc.objectMouseOver = null;
+			}
+			else
+			{
+				// Get HIT distance
+				maxreach = this.mc.objectMouseOver.hitVec.distanceTo(aimsourcecopy2); // Set entityreach here - we can't hit an entity behind whatever this is...
+				crossVec = this.mc.objectMouseOver.hitVec;
+			}
+	
+			Entity pointedEntity = null;
+			Vec3d hitLocation = null;
+		
+			AxisAlignedBB bb = new AxisAlignedBB(
+					-maxreach, -maxreach, -maxreach, 
+					maxreach, maxreach, maxreach)
+					.offset(aimsourcecopy2.xCoord, aimsourcecopy2.yCoord,  aimsourcecopy2.zCoord).expand(1, 1, 1);
+			
+			List entitiesWithinCrosshairDist = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.renderViewEntity, bb);
+			
+			double reach = maxreach;
+			double dist = 0;
+			
+			for (int i = 0; i < entitiesWithinCrosshairDist.size(); ++i)
+			{
+				Entity entity = (Entity)entitiesWithinCrosshairDist.get(i);
+	
+				if (entity.canBeCollidedWith())
+				{
+					float borderSize = entity.getCollisionBorderSize();
+					AxisAlignedBB boundingBox = entity.boundingBox.expand((double)borderSize, (double)borderSize, (double)borderSize);
+					RayTraceResult collision = boundingBox.calculateIntercept(aimsourcecopy2, crossVec);
+	
+					if (boundingBox.isVecInside(aimsourcecopy2))
+					{
+						if (0.0D < reach || reach == 0.0D)
+						{
+							pointedEntity = entity;                     
+							hitLocation = collision == null ? aimsourcecopy2 : collision.hitVec;
+							reach = 0.0D;
+						}
+					}
+					else if (collision != null)
+					{
+						dist = aimsourcecopy2.distanceTo(collision.hitVec);
+	
+						if (dist < maxreach || reach == 0.0D)
+						{
+							boolean canRiderInteract = false;
+	
+	
+							if (entity == this.mc.getRenderViewEntity().getRidingEntity() && !canRiderInteract)
+							{
+								if (reach == 0.0D)
+								{
+									pointedEntity = entity;
+									hitLocation = collision.hitVec;
+								}
+							}
+							else
+							{
+								pointedEntity = entity;
+								hitLocation = collision.hitVec;
+							}
+						}
+					}
+				}
+			}
+	
+			
+			if (pointedEntity != null && hitLocation !=null )
+				crossVec = hitLocation;
+			
+			if (pointedEntity != null && (dist < entityReachDistance) ) {
+				this.mc.objectMouseOver = new RayTraceResult(pointedEntity, hitLocation);
+				crossVec = this.mc.objectMouseOver.hitVec;
+	
+				if (pointedEntity instanceof EntityLivingBase || pointedEntity instanceof EntityItemFrame) {
+					this.mc.pointedEntity = pointedEntity;
+				}
+			}
+			
+			// Set up crosshair position
+			float SLIGHTLY_CLOSER = 0.001f;
+			Vec3d cameraPos = mc.roomScale.getEyePos_World(mc.currentEye);
+			centerEyePosToCrossDirection = cameraPos.subtract(crossVec).normalize();   // VIVE use camerapos
+			crossX = (float)(crossVec.xCoord - (centerEyePosToCrossDirection.xCoord*SLIGHTLY_CLOSER) - interpolatedPlayerPos.xCoord);
+			crossY = (float)(crossVec.yCoord - (centerEyePosToCrossDirection.yCoord*SLIGHTLY_CLOSER) - interpolatedPlayerPos.yCoord);
+			crossZ = (float)(crossVec.zCoord - (centerEyePosToCrossDirection.zCoord*SLIGHTLY_CLOSER) - interpolatedPlayerPos.zCoord);
+	
+			// VIVE START - teleport movement
+			if (!mc.vrPlayer.getFreeMoveMode() && mc.gameSettings.keyBindForward.getIsKeyPressed()) { mc.vrPlayer.updateTeleportDestinations(this, mc, mc.getRenderViewEntity());}
+			// VIVE END - teleport movement
+	
+			/** END MINECRIFT */    
+		}
+	}
+
+	private void debugViewDirection(float par1, EntityLivingBase var4, RenderGlobal var5, Frustum var14,
+			boolean hasForge, boolean renderOutline) {
+		EntityPlayer var18;
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+		GL11.glPushMatrix();
+		RenderHelper.enableStandardItemLighting();
+		this.mc.mcProfiler.endStartSection("entities");
+	
+	
+		var5.renderEntities(var4, var14, par1);
+	
+		RenderHelper.disableStandardItemLighting();
+		this.disableLightmap();
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+		GL11.glPushMatrix();
+		/** MINECRIFT */
+		if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && renderOutline)     // Minecrift
+		{
+			var18 = (EntityPlayer)var4;
+			GL11.glDisable(GL11.GL_ALPHA_TEST);
+			this.mc.mcProfiler.endStartSection("outline");
+	
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+		}
+	}
+
+	public void drawLine(Vec3d start, Vec3d end)
+	{
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
+		GL11.glLineWidth(6.0F);
+		GL11.glDisable(GL11.GL_TEXTURE_2D);
+		GL11.glDepthMask(false);
+
+		Tessellator var2 = Tessellator.getInstance();
+		var2.startDrawing(GL11.GL_LINE_STRIP);
+		var2.addVertex(start.xCoord, start.yCoord, start.zCoord);
+		var2.addVertex(end.xCoord, end.yCoord, end.zCoord);
+		var2.draw();
+
+		GL11.glDepthMask(true);
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+		GL11.glDisable(GL11.GL_BLEND);
+	}
+
+	public void orientModelView(boolean correctOffsets, boolean adjustHeight)   // VIVE added param
+	{
+		// Rotation
+		if (this.mc.gameSettings.thirdPersonView == 2)	GL11.glRotatef((float) -this.headRoll, 0.0F, 0.0F, 1.0F);
+		else GL11.glMultMatrix(mc.roomScale.getHMDMatrix_World());
+			
+		Vec3d campos = getCameraPos_Render();
+	//	Vec3d center = mc.roomScale.getRoomOriginPos_World();
+		// Position
+	
+		float x = (float) (campos.xCoord );
+		float y = (float) (campos.yCoord);
+		float z = (float) (campos.zCoord );
+		GL11.glTranslatef(x,y,z);
+
+		if (correctOffsets)
+		{
+			// Correct for yaw / pitch offsets
+//			GL11.glRotatef(this.lookPitchOffset, 1.0F, 0.0F, 0.0F);
+//			GL11.glRotatef(this.lookYawOffset, 0.0F, 1.0F, 0.0F);
+		}
+	}
+
+	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+	 * @param par1
+	 */
+	private void renderGuiLayer(float par1)
+	{
+		if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame || this.mc.showSplashScreen)
+			{
+				// Pass matrici on to OpenGL...
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glLoadIdentity();
+		
+				// Minecrift - use correct projection
+				if (this.mc.stereoProvider.isStereo())
+				{
+					GL11.glMultMatrix(eyeproj[mc.currentEye.value()]);
+				}
+				else
+				{
+					Project.gluPerspective(this.mc.getRenderViewEntity() == null ? 90f : this.getFOVModifier(par1, true), (float) this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+				}
+			
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glLoadIdentity();
+			
+				// VIVE START - custom GUI position
+				MCOpenVR.applyGUIModelView(this.mc.currentEye); //MCOpenVR.java, pushes.
+					///JRBUDDA MAIN MENU ROOM            
+					if(mc.theWorld == null || mc.currentScreen instanceof GuiWinGame){		
+						rendserJrbuddasAwesomeMainMenuRoom();			
+					}
+					//END JRBUDDA'S AWESOME MAIN MENU ROOM       
+					this.mc.guiFramebuffer.bindFramebufferTexture();
+					
+					GL11.glDisable(GL11.GL_CULL_FACE);
+					GL11.glEnable(GL11.GL_TEXTURE_2D);
+			
+					// Prevent black border at top / bottom of GUI
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+		
+					// Set texture filtering
+					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+		
+					if (this.mc.theWorld != null && !( mc.currentScreen instanceof GuiWinGame))
+					{
+						GL11.glColor4f(1, 1, 1, this.mc.vrSettings.hudOpacity);
+						GL11.glEnable(GL11.GL_ALPHA_TEST);
+					}
+					else{
+						GL11.glColor4f(1, 1, 1, 0.5f);
+						GL11.glDisable(GL11.GL_ALPHA_TEST);
+					}
+		
+					if (this.mc.vrSettings.hudOcclusion == false || this.mc.currentScreen != null){
+						// Never use depth test for in game menu - so you can always see it!
+						GL11.glDisable(GL11.GL_DEPTH_TEST);			
+					}
+		
+					//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.	
+					GL11.glDisable(GL11.GL_BLEND);	
+		
+					GL11.glAlphaFunc(GL11.GL_GREATER, 0.01f);
+				//	OpenGlHelper.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE_MINUS_SRC_COLOR, 1, 0); //color blend for corsshair transparency
+				//	OpenGlHelper.glBlendFunc(GL11.GL_ONE, GL11.GL_ZERO,0,1);
+					float scale = MCOpenVR.guiScale; // * this.mc.vroptions.hudscale
+					
+					GL11.glScalef(scale, scale, scale);
+										
+					//Render framebuffer onto world projection
+					drawSizedQuad(this.mc.guiFramebuffer.framebufferWidth, this.mc.guiFramebuffer.framebufferHeight, 1.5f); //this.mc.vrSettings.hudScale);
+					
+			//		OpenGlHelper.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, 1, 0); 
+		
+					GL11.glDisable(GL11.GL_BLEND);
+					GL11.glEnable(GL11.GL_DEPTH_TEST);
+					GL11.glEnable(GL11.GL_CULL_FACE);
+		
+				GL11.glPopMatrix();// undo extra push in applyguithing
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+		
+		
+			}
+	}
+
+	//VIVE
+	public void renderDebugAxes(int r, int g, int b){
+		renderCircle(new Vec3d(0, 0, 0), (float) .05, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0, .01, 0), (float) .03, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0,0.02, 0), (float) .01, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0, 0, .15), (float) .02, 32, r, g, b	, 255, 2);
+	
+	}
+
+	//TODO: move this into Guiingame where it belongs.
+	/** This draws the normal 2d menu/GUI elements to the framebuffer, to be rendered into the world projection later (in renderFramebufferIntoWorld)
+	 * @param renderPartialTicks
+	 * @param tickDuration
+	 */
+	public void drawFramebuffer(float renderPartialTicks, long tickDuration)    // VIVE - added parameter for debug info
+	{
+
+		this.guiScreenShowingThisFrame = false;
+		this.inWorldGuiScreenShowingThisFrame = false;
+
+		int mouseX = 0;
+		int mouseY = 0;
+		final ScaledResolution var15 = new ScaledResolution(this.mc);
+
+		
+		if (this.mc.showSplashScreen)
+		{
+    		this.mc.showSplash(this.mc.getFramebuffer());
+		}
+		else if (this.mc.isIntegratedServerLaunching())
+		{
+			this.guiScreenShowingThisFrame = true;
+			this.mc.loadingScreen.render();
+		}
+		else //always for vive, never for mono
+		{
+			if ((this.mc.theWorld != null && !this.mc.vrSettings.hideGui && this.mc.thePlayer.getSleepTimer() == 0) 
+					|| this.mc.currentScreen != null)
+			{
+								
+				//Render all UI elements into guiFBO
+				GL11.glClearColor(0, 0, 0, 0);
+				GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glLoadIdentity();
+				GL11.glOrtho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glLoadIdentity();
+				GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+
+
+				if (this.mc.theWorld != null && this.mc.currentScreen != null)
+					this.inWorldGuiScreenShowingThisFrame = true; // In game menus will open at look forward orient, with no depth check applied
+				else
+					this.guiScreenShowingThisFrame = true;        // Hud elements will open at body forward orient, with depth check applied if necessary
+			}
+
+			if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame)
+			{
+				// Display loading / progress window if necessary
+				if (this.mc.theWorld != null && !this.mc.vrSettings.hideGui /*&& !this.blankGUIUntilWorldValid*/)
+				{
+
+					//Draw in game HUD overlay
+					GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+
+					Object fmlCommonHandler = null;
+					
+					//Render HUD elements
+					this.mc.ingameGUI.renderGameOverlay(renderPartialTicks, this.mc.currentScreen != null, 0, 0);
+
+					mc.guiAchievement.updateAchievementWindow();
+
+					GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+				}
+
+				//        if (this.blankGUIUntilWorldValid) {
+				//            if (this.mc.theWorld != null)
+				//                this.blankGUIUntilWorldValid = false;
+				//        }
+
+				if (this.mc.currentScreen != null /*&& !this.blankGUIUntilWorldValid*/)
+				{
+
+					final int mouseX1 = mouseX = this.mc.currentScreen.getMouseX();
+					final int mouseY1 = mouseY = this.mc.currentScreen.getMouseY();
+
+					try
+					{
+						boolean drawScreenHandled = false;
+
+
+						if (!drawScreenHandled)
+						{
+							this.mc.currentScreen.drawScreen(mouseX, mouseY, renderPartialTicks);
+
+							if(mc.currentScreen !=null){ //wtf pixelmon?
+							
+							//	Draw GUI crosshair
+							if (mc.stereoProvider.isStereo()){					
+								if(MCOpenVR.controllerMouseValid){
+									mc.ingameGUI.drawMouseMenuQuad(mc.currentScreen.getMouseX(),mc.currentScreen.getMouseY())		;				
+								}
+							} else  mc.ingameGUI.drawMouseMenuQuad(mc.currentScreen.getMouseX(),mc.currentScreen.getMouseY())	;
+							}
+						}
+
+					}
+					catch (Throwable throwable)
+					{
+//						CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Rendering screen");
+//						CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
+//						crashreportcategory.addCrashSectionCallable("Screen name", new Callable() {
+//							private static final String __OBFID = "CL_00000948";
+//
+//							public String call() {
+//								return Minecraft.getMinecraft().currentScreen.getClass().getCanonicalName();
+//							}
+//						});
+//						crashreportcategory.addCrashSectionCallable("Mouse location", new Callable() {
+//							private static final String __OBFID = "CL_00000950";
+//
+//							public String call() {
+//								return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[]{Integer.valueOf(mouseX1), Integer.valueOf(mouseY1), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
+//							}
+//						});
+//						crashreportcategory.addCrashSectionCallable("Screen size", new Callable() {
+//							private static final String __OBFID = "CL_00000951";
+//
+//							public String call() {
+//								return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[]{Integer.valueOf(var15.getScaledWidth()), Integer.valueOf(var15.getScaledHeight()), Integer.valueOf(Minecraft.getMinecraft().displayWidth), Integer.valueOf(Minecraft.getMinecraft().displayHeight), Integer.valueOf(var15.getScaleFactor())});
+//							}
+//						});
+//						throw new ReportedException(crashreport);
+					}
+
+					GL11.glDisable(GL11.GL_LIGHTING); //inventory messes up fog color sometimes... This fixes
+					GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+
+				}
+			}
+		}
+
+		// VIVE added debug info to HUD
+		if (mc.gameSettings.showDebugInfo && mc.gameSettings.showDebugProfilerChart)
+		{
+			mc.displayDebugInfo(tickDuration);
+		}
+
+		//update mipmaps for Gui layer
+		this.mc.getFramebuffer().bindFramebufferTexture();
+		this.mc.getFramebuffer().genMipMaps();
+		this.mc.getFramebuffer().unbindFramebufferTexture();
+		
+	}
+
+
+	private void renderTeleportArc(OpenVRPlayer vrPlayer) {
+
+		if ( vrPlayer.vrMovementStyle.showBeam && vrPlayer.movementTeleportProgress > 0.0f
+				&& vrPlayer.movementTeleportArcSteps > 1)
+		{
+			mc.mcProfiler.startSection("teleportArc");
+
+		
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+			GL11.glDisable(GL11.GL_TEXTURE_2D);
+			GL11.glDisable(GL11.GL_LIGHTING);
+			GL11.glEnable(GL11.GL_DEPTH_TEST);
+
+			Tessellator tes = Tessellator.getInstance();
+			
+			tes.startDrawingQuads();
+
+				double VOffset = vrPlayer.lastTeleportArcDisplayOffset;
+	
+				boolean validLocation = (vrPlayer.movementTeleportDestination.xCoord != 0
+						|| vrPlayer.movementTeleportDestination.yCoord != 0
+						|| vrPlayer.movementTeleportDestination.zCoord != 0);
+	
+				int validLineR = 205;
+				int validLineG = 169;
+				int validLineB = 205;
+				if (!validLocation)
+				{
+					// invalid location
+					tes.setColorRGBA(83, 75, 83, 128);
+				}
+				else
+				{
+					tes.setColorRGBA(validLineR, validLineG, validLineB, 128);
+					VOffset = this.mc.stereoProvider.getCurrentTimeSecs()*vrPlayer.vrMovementStyle.textureScrollSpeed * 0.6;
+					vrPlayer.lastTeleportArcDisplayOffset = VOffset;
+				}
+	
+				float segmentHalfWidth = vrPlayer.vrMovementStyle.beamHalfWidth * 0.15f;
+				int segments = vrPlayer.movementTeleportArcSteps - 1;
+				if (vrPlayer.vrMovementStyle.beamGrow)
+				{
+					segments = (int) ((double) segments * vrPlayer.movementTeleportProgress);
+				}
+				double segmentProgress = 1.0 / (double) segments;
+	
+				Vec3d up = new Vec3d(0,1,0);
+	
+				for (int i=0;i<segments;i++)
+				{
+					double progress = ((double)i / (double)segments) + VOffset * segmentProgress;
+					int progressBase = (int)MathHelper.floor_double(progress);
+					progress -= (float) progressBase;
+	
+					Vec3d start = mc.vrPlayer.getInterpolatedArcPosition((float)(progress - segmentProgress * 0.4f));
+					start.xCoord -= interpolatedPlayerPos.xCoord;
+					start.yCoord -= interpolatedPlayerPos.yCoord;
+					start.zCoord -= interpolatedPlayerPos.zCoord;
+	
+					Vec3d end = mc.vrPlayer.getInterpolatedArcPosition((float)progress);
+					end.xCoord -= interpolatedPlayerPos.xCoord;
+					end.yCoord -= interpolatedPlayerPos.yCoord;
+					end.zCoord -= interpolatedPlayerPos.zCoord;
+	
+					float shift = (float)progress * 2.0f;
+					renderBox(tes, start, end, -segmentHalfWidth, segmentHalfWidth, (-1.0f + shift ) * segmentHalfWidth, (1.0f + shift) * segmentHalfWidth, up);
+				}
+				
+			tes.draw();
+
+			if (validLocation){ //draw landing splash
+				Vec3d circlePos = new Vec3d(vrPlayer.movementTeleportDestination.xCoord, vrPlayer.movementTeleportDestination.yCoord, vrPlayer.movementTeleportDestination.zCoord) ;
+
+				int side = 1; //vrPlayer.movementTeleportDestinationSideHit;
+
+				float o = 0.01f;
+
+				circlePos.xCoord -= interpolatedPlayerPos.xCoord;
+				circlePos.yCoord -= interpolatedPlayerPos.yCoord;
+				circlePos.zCoord -= interpolatedPlayerPos.zCoord;
+
+				if (side ==0)   circlePos.yCoord -= o;
+				if (side ==1)   circlePos.yCoord += o;
+				if (side ==2)   circlePos.zCoord -= o;
+				if (side ==3)   circlePos.zCoord += o;
+				if (side ==4)   circlePos.xCoord -= o;
+				if (side ==5)   circlePos.xCoord += o;						
+
+				renderCircle(circlePos, 0.2f, 32, validLineR, validLineG, validLineB, 64,side);
+				if (side ==0)   circlePos.yCoord -= o;
+				if (side ==1)   circlePos.yCoord += o;
+				if (side ==2)   circlePos.zCoord -= o;
+				if (side ==3)   circlePos.zCoord += o;
+				if (side ==4)   circlePos.xCoord -= o;
+				if (side ==5)   circlePos.xCoord += o;
+				renderCircle(circlePos, 0.15f, 32, validLineR, validLineG, validLineB, 128,side);
+				if (side ==0)   circlePos.yCoord -= o;
+				if (side ==1)   circlePos.yCoord += o;
+				if (side ==2)   circlePos.zCoord -= o;
+				if (side ==3)   circlePos.zCoord += o;
+				if (side ==4)   circlePos.xCoord -= o;
+				if (side ==5)   circlePos.xCoord += o;
+				renderCircle(circlePos, 0.1f, 32, validLineR, validLineG, validLineB, 128,side);
+			}
+
+			mc.mcProfiler.endSection(); // teleport arc
+		}
+	}
+
+	public Vec3d getCameraPos_Render(){
+		Vec3d out = mc.roomScale.getEyePos_World(mc.currentEye).subtract(mc.getRenderViewEntity().getEyeLocation(1));
+		return out;
+	}
+	
+	public Vec3d getMainHandPos_Render(){
+		Vec3d out =  mc.roomScale.getControllerMainPos_World().subtract(mc.getRenderViewEntity().getEyeLocation(1));
+		return out;
+	}
+	
+	public Vec3d getOffHandPos_Render(){
+		Vec3d out =  mc.roomScale.getControllerOffhandPos_World().subtract(mc.getRenderViewEntity().getEyeLocation(1));
+		return out;
+	}
+	
+	
+	//please push your matrix first. and pop after.
+	public void SetupRenderingAtController(int controller){
+		Vec3d aimSource = getMainHandPos_Render();
+		if(controller == 1)aimSource= getOffHandPos_Render(); //TODO: cmon lazy.
+	
+		if (aimSource!=null)
+		{ //move from head to hand origin.
+				GL11.glTranslatef(
+					(float) (-aimSource.xCoord ),
+					(float) (-aimSource.yCoord ),
+					(float) (-aimSource.zCoord ));
+		}
+		
+			GL11.glScalef(mc.vrSettings.vrWorldScale , mc.vrSettings.vrWorldScale , mc.vrSettings.vrWorldScale );
+		
+    //    	Vector3f fore = new Vector3f(0,0,1);       
+   //     	Matrix4f rotation = this.mc.vrPlayer.get.getAimRotation(controller);  
+        	
+        	FloatBuffer buf = mc.roomScale.getControllerMatrix_World(controller);
+        	
+	    	if(!mc.bowTracker.isDrawing || controller == 0){ //doing this elsewhere
+	    		GL11.glMultMatrix(buf);      
+  	
+        	}     
+	}
+	
+	// VIVE START - render functions
+	public void renderLeftHand(float nano)
+	{
+
+		if (mc.thePlayer == null)
+			return;
+
+		mc.mcProfiler.startSection("renderLeftHand");
+
+	//	int handBrightness = mc.thePlayer.getBrightnessForRender(1.0f);
+	//	int var12 = handBrightness % 65536;
+	//	int var13 = handBrightness / 65536;
+	//	OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float) var12 / 1.0F, (float) var13 / 1.0F);
+
+		GL11.glLoadIdentity();
+	
+    	RenderHelper.enableStandardItemLighting();    
+		GL11.glEnable(GL11.GL_LIGHTING);
+		
+		GL11.glPushMatrix();
+
+			orientModelView(false,  false);	
+				
+			GL11.glPushMatrix();
+
+				SetupRenderingAtController(1);	//does not push
+
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		
+				mc.getTextureManager().bindTexture(mc.thePlayer.getLocationSkin());
+	
+				this.enableLightmap();
+					
+					if(mc.bowTracker.isActive(mc.thePlayer)){ //render bow
+						int c = 1;
+						if (mc.vrSettings.vrReverseShootingEye) c = 0;
+						renderItemInFirstPersonForController(nano, c, mc.thePlayer.inventory.getCurrentItem());
+					}
+					else //just hand
+						renderItemInFirstPersonForController(nano, 1, null);
+					
+				this.disableLightmap((double) nano);
+			
+					//	TP energy
+				if (mc.vrSettings.vrLimitedSurvivalTeleport && !mc.vrPlayer.getFreeMoveMode() && mc.playerController.isNotCreative() && mc.vrPlayer.vrMovementStyle.arcAiming && !mc.bowTracker.isActive(mc.thePlayer)){
+					GL11.glPushMatrix();
+//							GL11.glRotatef(90, 0,0, 1f);
+						GL11.glTranslatef(0.0f,- 0.005f, .05f);
+			
+						GL11.glEnable(GL11.GL_BLEND);
+						GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+						GL11.glDisable(GL11.GL_TEXTURE_2D);
+			//			GL11.glDisable(GL11.GL_LIGHTING);
+			
+						Vec3d start = new Vec3d(0,0,0);
+			
+						float r;
+						float max = .015f;
+						if (mc.vrPlayer.movementTeleportProgress > 0 ) {      	
+							r = (float) ( mc.vrPlayer.getTeleportEnergy() - 4 * mc.vrPlayer.movementTeleportDistance  ) / 100 * max;
+						} else {     	
+							r = mc.vrPlayer.getTeleportEnergy() / 100 * max;
+						}
+			
+						if(r<0){r=0;}
+			
+						renderCircle(start.addVector(0, .05001, 0), r, 32, 255, 163, 255, 128, 1);
+						renderCircle(start.addVector(0, .05, 0), max, 32, 255, 163, 255, 50, 1);    
+			
+						GL11.glEnable(GL11.GL_TEXTURE_2D);
+						GL11.glDisable(GL11.GL_BLEND);
+			//			GL11.glEnable(GL11.GL_LIGHTING);
+					GL11.glPopMatrix();
+				}
+	
+				mc.mcProfiler.endSection();
+
+				GL11.glDisable(GL11.GL_LIGHTING);
+
+			GL11.glPopMatrix();//back to hmd rendering
+		
+				
+			if(!mc.vrPlayer.getFreeMoveMode()){
+				if(mc.vrPlayer.vrMovementStyle.arcAiming) {
+					renderTeleportArc(mc.vrPlayer);   	
+				} else {
+					renderTeleportLine(mc.vrPlayer); 	
+				}	   
+			}
+			
+	    	RenderHelper.disableStandardItemLighting();    
+			GL11.glDisable(GL11.GL_LIGHTING);
+				
+		GL11.glPopMatrix();
+	}
+
+	private void renderMainMenuHands()
+	{
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+			GL11.glLoadIdentity();
+			if (this.mc.stereoProvider.isStereo())
+			{
+				GL11.glMultMatrix(eyeproj[mc.currentEye.value()]);
+			}
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+				GL11.glLoadIdentity();
+		
+				GL11.glDisable(GL11.GL_TEXTURE_2D);
+				GL11.glDisable(GL11.GL_ALPHA_TEST);
+				GL11.glDisable(GL11.GL_DEPTH_TEST);
+		
+				// counter head rotation
+
+				GL11.glMultMatrix(mc.roomScale.getHMDMatrix_World());
+
+				
+				//OK SO when world == null the origin is at your face.
+				
+				
+				Tessellator tes = Tessellator.getInstance();
+		
+				for (int c=0;c<2;c++)
+				{
+					tes.startDrawingQuads();
+		
+					tes.setColorRGBA(255 - 127 * c,255 - 127 * c,255 - 127 * c,255);
+					
+					Vec3d controllerPos = mc.roomScale.getEyePos_World(mc.currentEye).subtract(mc.roomScale.getControllerPos_World(c));
+					
+					GL11.glPushMatrix();
+						GL11.glTranslatef(
+								(float)controllerPos.xCoord,
+								(float)controllerPos.yCoord,
+								(float)controllerPos.zCoord);
+			
+			
+						Vec3d start = new Vec3d(0,0,0);
+			
+//						Matrix4f controllerRotation = mc.lookaimController.getAimRotation(c);
+//						Vector3f forward = new Vector3f(0,0,-0.17f);
+//						Vector3f dir = controllerRotation.transform(forward);
+						Vec3d dir = mc.roomScale.getControllerMainDir_World();
+						if(c==1) dir = mc.roomScale.getControllerOffhandDir_World();
+						Vec3d up = mc.roomScale.getCustomControllerVector(c, new Vec3d(0, 1, 0));
+				
+						Vec3d end = new Vec3d(
+								start.xCoord - dir.xCoord*.18,
+								start.yCoord - dir.yCoord*.18,
+								start.zCoord - dir.zCoord*.18);
+			
+						renderBox(tes, start, end, -0.02f, 0.02f, -0.025f, 0.00f, up);
+						tes.draw();
+					GL11.glPopMatrix();     
+				}
+		
+			
+				
+				GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+			GL11.glPopMatrix();
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+	GL11.glPopMatrix();
+	}
+
+	public void renderCircle(Vec3d pos, float radius, int edges, int r, int g, int b, int a, int side)
+	{
+//		Tessellator tes = Tessellator.getInstance();
+//
+//		boolean blend = GL11.glIsEnabled(GL11.GL_BLEND);
+//		boolean tex =  GL11.glIsEnabled(GL11.GL_TEXTURE_2D);
+//		boolean light =  GL11.glIsEnabled(GL11.GL_LIGHTING);
+//		boolean cull =  GL11.glIsEnabled(GL11.GL_CULL_FACE);
+//
+//		GL11.glEnable(GL11.GL_BLEND);
+//		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+//		GL11.glDisable(GL11.GL_TEXTURE_2D);
+//		GL11.glDisable(GL11.GL_LIGHTING);
+//		GL11.glDisable(GL11.GL_CULL_FACE);
+//
+//		tes.startDrawing(GL11.GL_TRIANGLE_FAN);
+//
+//		tes.setColorRGBA(r, g, b, a);
+//
+//		tes.addVertex(pos.xCoord, pos.yCoord, pos.zCoord);
+//
+//		for (int i=0;i<edges + 1;i++)
+//		{
+//			float startAngle;
+//			startAngle = ( (float) (i) / (float) edges ) * (float) Math.PI * 2.0f;
+//
+//			if (side == 0 || side == 1) { //y
+//				float x = (float) pos.xCoord + (float) Math.cos(startAngle) * radius;
+//				float y = (float) pos.yCoord;
+//				float z = (float) pos.zCoord + (float) Math.sin(startAngle) * radius;
+//				tes.addVertex(x, y, z);
+//			} else if (side == 2 || side == 3) { //z
+//				float x = (float) pos.xCoord + (float) Math.cos(startAngle) * radius;
+//				float y = (float) pos.yCoord + (float) Math.sin(startAngle) * radius;
+//				float z = (float) pos.zCoord; 
+//				tes.addVertex(x, y, z);
+//			} else if (side == 4 || side == 5){ //x
+//				float x = (float) pos.xCoord ;
+//				float y = (float) pos.yCoord + (float) Math.cos(startAngle) * radius;
+//				float z = (float) pos.zCoord + (float) Math.sin(startAngle) * radius;
+//				tes.addVertex(x, y, z);
+//			} else{}
+//
+//		}
+//
+//		tes.draw();       
+//
+//		if(!blend){GL11.glDisable(GL11.GL_BLEND);}
+//		if (tex){GL11.glEnable(GL11.GL_TEXTURE_2D);}
+//		if(light){GL11.glEnable(GL11.GL_LIGHTING);}
+//		if(cull){GL11.glEnable(GL11.GL_CULL_FACE);}
+	}
+
+	private void renderBox(Tessellator tes, Vec3d start, Vec3d end, float minX, float maxX, float minY, float maxY, Vec3d up)
+	{
+		Vec3d forward = start.subtract(end).normalize();
+		Vec3d right = forward.crossProduct(up);
+		up = right.crossProduct(forward);
+	
+		Vec3d left = new Vec3d(
+				right.xCoord * minX,
+				right.yCoord * minX,
+				right.zCoord * minX);
+	
+		right = right.multiply(maxX);
+		
+	
+		Vec3d down = new Vec3d(
+				up.xCoord * minY,
+				up.yCoord * minY,
+				up.zCoord * minY);
+	
+		up = up.multiply(maxY);
+
+	
+		Vec3d backRightBottom    = start.addVector(   right.xCoord+down.xCoord,   right.yCoord+down.yCoord,   right.zCoord+down.zCoord);
+		Vec3d backRightTop       = start.addVector(   right.xCoord+up.xCoord,     right.yCoord+up.yCoord,     right.zCoord+up.zCoord);
+		Vec3d backLeftBottom     = start.addVector(   left.xCoord+down.xCoord,    left.yCoord+down.yCoord,    left.zCoord+down.zCoord);
+		Vec3d backLeftTop        = start.addVector(   left.xCoord+up.xCoord,      left.yCoord+up.yCoord,      left.zCoord+up.zCoord);
+		Vec3d frontRightBottom   = end.addVector(     right.xCoord+down.xCoord,   right.yCoord+down.yCoord,   right.zCoord+down.zCoord);
+		Vec3d frontRightTop      = end.addVector(     right.xCoord+up.xCoord,     right.yCoord+up.yCoord,     right.zCoord+up.zCoord);
+		Vec3d frontLeftBottom    = end.addVector(     left.xCoord+down.xCoord,    left.yCoord+down.yCoord,    left.zCoord+down.zCoord);
+		Vec3d frontLeftTop       = end.addVector(     left.xCoord+up.xCoord,      left.yCoord+up.yCoord,      left.zCoord+up.zCoord);
+	
+//		tes.addVertex(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord);
+//		tes.addVertex(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord);
+//		tes.addVertex(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord);
+//		tes.addVertex(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord);    // back
+//	
+//		tes.addVertex(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord);   // front
+//		tes.addVertex(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord);
+//		tes.addVertex(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord);
+//		tes.addVertex(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord);
+//	
+//		tes.addVertex(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord);    // right
+//		tes.addVertex(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord);
+//		tes.addVertex(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord);
+//		tes.addVertex(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord);
+//	
+//		tes.addVertex(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord); // left
+//		tes.addVertex(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord);
+//		tes.addVertex(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord);
+//		tes.addVertex(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord);
+//	
+//		tes.addVertex(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord);
+//		tes.addVertex(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord);
+//		tes.addVertex(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord);
+//		tes.addVertex(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord);       // top
+//	
+//		tes.addVertex(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord);       // bottom
+//		tes.addVertex(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord);
+//		tes.addVertex(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord);
+//		tes.addVertex(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord);
+	}
+
+	//awesome.
+	private void rendserJrbuddasAwesomeMainMenuRoom() {
+		GL11.glClearColor(.1f, .1f, .1f, 0.1f);       
+		GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);        
+		GL11.glDisable(GL11.GL_BLEND);   
+		GL11.glColor4f(0.5f, 0.5f, 0.5f, 1f);
+		
+		GL11.glEnable(GL11.GL_DEPTH_TEST);	
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+		GL11.glEnable(GL11.GL_LIGHTING);
+		GL11.glEnable(GL11.GL_LIGHT0);
+		GL11.glEnable(GL11.GL_CULL_FACE);
+	
+		Minecraft.getMinecraft().renderEngine.bindTexture(Gui.optionsBackground);
+		
+	//	float yo = -camRelY;
+		float s = 3f;
+		int repeat = 30; 
+		int w = 5;
+		
+		GL11.glPushMatrix();
+		GL11.glScalef(2f, 2f, 2f);
+	
+			GL11.glTranslatef(0f, 0, 1.3f);
+	
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, setFogColorBuffer(0f,0f,-0.2f,1));           
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, setFogColorBuffer(1,1,1,1));
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_AMBIENT, setFogColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+				GL11.glLightModel(GL11.GL_LIGHT_MODEL_AMBIENT, setFogColorBuffer(0, 0, 0, 1.0F));
+				GL11.glShadeModel(GL11.GL_SMOOTH);
+	
+				for (int i = 0; i <= 6; i++) {
+					GL11.glPushMatrix();
+						float t = -1.3f;
+	
+						if (i == 1) GL11.glRotatef(90f, 0,1, 0);
+						if (i == 2) GL11.glRotatef(-90f, 0,1, 0);
+						if (i == 3) GL11.glRotatef(180f, 0,1, 0);
+						if (i == 4) GL11.glRotatef(-180f, 0,1, 0);
+						if (i == 5){
+							t= -.6f;
+							GL11.glRotatef(90, 1,0, 0);
+						}
+						if (i == 6) {
+							t= (float) -1.3f/2f;
+							GL11.glRotatef(-90, 1,0, 0);
+						}
+	
+						GL11.glTranslatef(0f, 0, t);			        	
+						GL11.glBegin(GL11.GL_QUADS);	  	
+							GL11.glTexCoord2f(0.0f, 0.0f);
+							GL11.glVertex3f(-(s / 2f), -(s * 1) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+							GL11.glTexCoord2f(repeat, 0.0f);
+							GL11.glVertex3f(s / 2f, -(s * 1) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+							GL11.glTexCoord2f(repeat, repeat);
+							GL11.glVertex3f(s / 2f, (s * 1) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+							GL11.glTexCoord2f(0.0f, repeat);
+							GL11.glVertex3f(-(s / 2f), (s * 1) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+						GL11.glEnd();       
+					GL11.glPopMatrix();   	   
+	
+				}         
+	
+				GL11.glTranslatef(0f, 0, -1.3f);
+	
+				
+				GL11.glPopMatrix();   
+		GL11.glPopMatrix();   
+	
+		RenderHelper.disableStandardItemLighting();
+	}
+
+	private void renderTeleportLine(OpenVRPlayer vrPlayer){
+		// VIVE START - render teleport line
+	
+		boolean renderTeleportLine = vrPlayer.movementTeleportDestination.xCoord != 0
+				|| vrPlayer.movementTeleportDestination.yCoord != 0
+				|| vrPlayer.movementTeleportDestination.zCoord != 0;
+		if (renderTeleportLine && vrPlayer.movementTeleportProgress>0.0 && vrPlayer.vrMovementStyle.showBeam
+				)
+		{
+			mc.mcProfiler.startSection("teleportLine");
+	
+			float alpha = 0.3f;
+			GL11.glColor4f(1.0f, 1.0f, 1.0f, alpha);
+			GL11.glDisable(GL11.GL_LIGHTING);
+			this.mc.getTextureManager().bindTexture(vrPlayer.vrMovementStyle.texture);
+			GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
+			GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+			GL11.glDisable(GL11.GL_CULL_FACE);
+	
+			Tessellator tes = Tessellator.getInstance();
+			//tes.startDrawingQuads();
+	
+			Vec3d start = mc.vrPlayer.getControllerOffhandDir_World();
+			start.xCoord -= interpolatedPlayerPos.xCoord;
+			start.yCoord -= interpolatedPlayerPos.yCoord;
+			start.zCoord -= interpolatedPlayerPos.zCoord;
+			//Vec3d start = new Vec3d(0.2, 0.5, 0);
+			Vec3d end = new Vec3d(vrPlayer.movementTeleportDestination.xCoord - interpolatedPlayerPos.xCoord,
+					vrPlayer.movementTeleportDestination.yCoord - interpolatedPlayerPos.yCoord,
+					vrPlayer.movementTeleportDestination.zCoord - interpolatedPlayerPos.zCoord);
+			Vec3d delta = start.subtract(end);
+			Vec3d forward = delta.normalize();
+			Vec3d up = new Vec3d(0,1,0);
+			Vec3d right = forward.crossProduct(up);
+			float distance = (float) delta.lengthVector();
+	
+			float segmentLength = vrPlayer.vrMovementStyle.beamSegmentLength;
+			float segmentHalfWidth = vrPlayer.vrMovementStyle.beamHalfWidth;
+	
+			int segments = (int) (distance / segmentLength);
+			if (vrPlayer.vrMovementStyle.beamGrow)
+			{
+				segments = (int) ((double) segments * vrPlayer.movementTeleportProgress);
+			}
+			segments++;
+	
+			if (distance<1.5f)
+				segments = 0;
+	
+			int textureVStrips = vrPlayer.vrMovementStyle.beamVStrips;
+			float textureVStripHeight = 1.0f / (float)textureVStrips;
+			Vec3d segmentOrigin = new Vec3d(0,0,0);
+			Vec3d BL = new Vec3d(0,0,0);
+			Vec3d BR = new Vec3d(0,0,0);
+			Vec3d SBL = new Vec3d(0,0,0);
+			Vec3d SBR = new Vec3d(0,0,0);
+	
+			for (int i=0;i<segments;i++)
+			{
+				float segmentDistance = segmentLength * i;
+				segmentOrigin.xCoord = start.xCoord + forward.xCoord*segmentDistance;
+				segmentOrigin.yCoord = start.yCoord + forward.yCoord*segmentDistance;
+				segmentOrigin.zCoord = start.zCoord + forward.zCoord*segmentDistance;
+	
+				float VOffset = (float) -this.mc.stereoProvider.getCurrentTimeSecs()*vrPlayer.vrMovementStyle.textureScrollSpeed;
+				VOffset += (i%textureVStrips)*textureVStripHeight;
+	
+				if (i==0)
+				{
+					BL.xCoord = segmentOrigin.xCoord - right.xCoord * segmentHalfWidth;
+					BL.yCoord = segmentOrigin.yCoord - right.yCoord * segmentHalfWidth;
+					BL.zCoord = segmentOrigin.zCoord - right.zCoord * segmentHalfWidth;
+	
+					BR.xCoord = segmentOrigin.xCoord + right.xCoord * segmentHalfWidth;
+					BR.yCoord = segmentOrigin.yCoord + right.yCoord * segmentHalfWidth;
+					BR.zCoord = segmentOrigin.zCoord + right.zCoord * segmentHalfWidth;
+	
+					SBL.xCoord = segmentOrigin.xCoord - up.xCoord * segmentHalfWidth;
+					SBL.yCoord = segmentOrigin.yCoord - up.yCoord * segmentHalfWidth;
+					SBL.zCoord = segmentOrigin.zCoord - up.zCoord * segmentHalfWidth;
+	
+					SBR.xCoord = segmentOrigin.xCoord + up.xCoord * segmentHalfWidth;
+					SBR.yCoord = segmentOrigin.yCoord + up.yCoord * segmentHalfWidth;
+					SBR.zCoord = segmentOrigin.zCoord + up.zCoord * segmentHalfWidth;
+				}
+	
+				float progress = (float)(i+0.5f)/(float)segments;
+				if (vrPlayer.vrMovementStyle.beamArc)
+				{
+					float arcHeight = (float) Math.sin(progress * Math.PI) * 1.0f;
+					float arcRight = arcHeight * 0.15f;
+					Vec3d arc = new Vec3d(up.xCoord * arcHeight + right.xCoord * arcRight,
+							up.yCoord * arcHeight + right.yCoord * arcRight,
+							up.zCoord * arcHeight + right.zCoord * arcRight);
+					segmentOrigin.xCoord += arc.xCoord;
+					segmentOrigin.yCoord += arc.yCoord;
+					segmentOrigin.zCoord += arc.zCoord;
+				}
+	
+				if (vrPlayer.vrMovementStyle.beamSpiral)
+				{
+					float angle = (float) ((segmentDistance / 2.0f) * 2 * Math.PI);
+					float spiralHeight = vrPlayer.vrMovementStyle.beamSpiralRadius;
+					float distanceLeft = distance - (segmentDistance + segmentLength);
+					if (distanceLeft < 3.0f)
+					{
+						spiralHeight *= (distanceLeft / 3.0f);
+					}
+	
+					Vec3d spiral = new Vec3d(
+							up.xCoord * spiralHeight * (float) Math.sin(angle)
+							+ right.xCoord * spiralHeight * Math.cos(angle),
+							up.yCoord * spiralHeight * (float) Math.sin(angle)
+							+ right.yCoord * spiralHeight * Math.cos(angle),
+							up.zCoord * spiralHeight * (float) Math.sin(angle)
+							+ right.zCoord * spiralHeight * Math.cos(angle)
+							);
+					segmentOrigin.xCoord += spiral.xCoord;
+					segmentOrigin.yCoord += spiral.yCoord;
+					segmentOrigin.zCoord += spiral.zCoord;
+				}
+	
+				if (vrPlayer.vrMovementStyle.beamWave)
+				{
+					float waveDistance = distance;//Math.min(6.0f, distance);
+					if (distance * vrPlayer.movementTeleportProgress < waveDistance)
+					{
+						float waveAmount = (float) Math.sin(segmentDistance * Math.PI * 2) * 0.1f;
+						waveAmount *= (1.0f - (distance * vrPlayer.movementTeleportProgress / waveDistance));
+						Vec3d wave = new Vec3d(right.xCoord * waveAmount,
+								right.yCoord * waveAmount,
+								right.zCoord * waveAmount);
+						segmentOrigin.xCoord += wave.xCoord;
+						segmentOrigin.yCoord += wave.yCoord;
+						segmentOrigin.zCoord += wave.zCoord;
+					}
+				}
+	
+				Vec3d FL = segmentOrigin.addVector(forward.xCoord * segmentLength - right.xCoord * segmentHalfWidth,
+						forward.yCoord * segmentLength - right.yCoord * segmentHalfWidth,
+						forward.zCoord * segmentLength - right.zCoord * segmentHalfWidth);
+				Vec3d FR = segmentOrigin.addVector(forward.xCoord * segmentLength + right.xCoord * segmentHalfWidth,
+						forward.yCoord * segmentLength + right.yCoord * segmentHalfWidth,
+						forward.zCoord * segmentLength + right.zCoord * segmentHalfWidth);
+	
+				tes.addVertexWithUV(BL.xCoord, BL.yCoord, BL.zCoord, 0, 0+VOffset);       // top
+				tes.addVertexWithUV(FL.xCoord, FL.yCoord, FL.zCoord, 0, textureVStripHeight+VOffset);
+				tes.addVertexWithUV(FR.xCoord, FR.yCoord, FR.zCoord, 1, textureVStripHeight+VOffset);
+				tes.addVertexWithUV(BR.xCoord, BR.yCoord, BR.zCoord, 1, 0+VOffset);
+	
+				// render again at 90 degrees
+				Vec3d SFL = segmentOrigin.addVector(forward.xCoord * segmentLength - up.xCoord * segmentHalfWidth,
+						forward.yCoord * segmentLength - up.yCoord * segmentHalfWidth,
+						forward.zCoord * segmentLength - up.zCoord * segmentHalfWidth);
+				Vec3d SFR = segmentOrigin.addVector(forward.xCoord * segmentLength + up.xCoord * segmentHalfWidth,
+						forward.yCoord * segmentLength + up.yCoord * segmentHalfWidth,
+						forward.zCoord * segmentLength + up.zCoord * segmentHalfWidth);
+	
+				if (vrPlayer.vrMovementStyle.renderVerticalStrip)
+				{
+					tes.addVertexWithUV(SBL.xCoord, SBL.yCoord, SBL.zCoord, 0, 0 + VOffset);       // top
+					tes.addVertexWithUV(SFL.xCoord, SFL.yCoord, SFL.zCoord, 0, textureVStripHeight + VOffset);
+					tes.addVertexWithUV(SFR.xCoord, SFR.yCoord, SFR.zCoord, 1, textureVStripHeight + VOffset);
+					tes.addVertexWithUV(SBR.xCoord, SBR.yCoord, SBR.zCoord, 1, 0 + VOffset);
+				}
+	
+				BL=FL;
+				BR=FR;
+				SBL=SFL;
+				SBR=SFR;
+			}
+			tes.draw();
+	
+			GL11.glEnable(GL11.GL_CULL_FACE);
+			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+	
+			mc.mcProfiler.endSection(); // "teleportLine"	
+		}
+	}
+
+	//checks around the eye position for an opaque block or water block so we can render fog and overlays for that eye
+	public Block getEyeCollisionBlock(EyeType eye){
+		//TODO this has to be totally redone and it may not be necessary anymore.
+//		Vec3d exact = mc.roomScale.getEyePos_World(eye);
+//		int var2 = (int) Math.floor(exact.xCoord);
+//		int var3 = (int) Math.floor(exact.yCoord);
+//		int var4 = (int) Math.floor(exact.zCoord);
+//	
+//		float l =	BlockLiquid.getLiquidHeightPercent(mc.theWorld.getBlockMetadata(var2, var3, var4));
+//		Block b = 	this.mc.theWorld.getBlock(var2, var3, var4);
+//	
+//		if (b.isNormalCube() ||
+//				(b.getMaterial() == Material.water && 
+//				(this.mc.theWorld.getBlock(var2, var3 +1 , var4).getMaterial() == Material.water  ||
+//				exact.yCoord - var3 < (1- l )) 
+//						)  
+//				) //head in block
+//		{          	
+//			eyeCollisionBlockPosLoc = new Vec3d(var2, var3, var4);
+//			return this.mc.theWorld.getBlock(var2, var3, var4);
+//		}
+//		else
+//		{
+//			for (int var6 = 0; var6 < 8; ++var6)
+//			{
+//				float var7 = ((float)((var6 >> 0) % 2) - 0.5F) * .07f;
+//				float var8 = ((float)((var6 >> 1) % 2) - 0.5F) * .07f;
+//				float var9 = ((float)((var6 >> 2) % 2) - 0.5F) * .07f;
+//				int var10 = MathHelper.floor_double(exact.xCoord + var7);
+//				int var11 = MathHelper.floor_double(exact.yCoord + var8);
+//				int var12 = MathHelper.floor_double(exact.zCoord + var9);
+//	
+//				if (this.mc.theWorld.getBlock(var10, var11, var12).isNormalCube())
+//				{
+//					eyeCollisionBlockPosLoc = new Vec3d(var10, var11, var12);
+//					return this.mc.theWorld.getBlock(var10, var11, var12);
+//				}
+//			}          
+//		}
+//	
+	return null;
+	
+	}
+
+	public Vec3d getCameraBlock(){
+		Vec3d cam = mc.roomScale.getHMDPos_World();
+		return new Vec3d(Math.floor(cam.xCoord), Math.floor(cam.yCoord), Math.floor(cam.zCoord));
+	}
+
+	public Vec3d getEyeBlock(EyeType eye){
+		Vec3d cam = mc.roomScale.getEyePos_World(eye);
+		return new Vec3d(Math.floor(cam.xCoord), Math.floor(cam.yCoord), Math.floor(cam.zCoord));
+	}
+
+	public boolean cameraIsInOpaqueBlock(){
+	
+		//        for (int var1 = 0; var1 < 8; ++var1)
+		//        {
+		//            float var2 = ((float)((var1 >> 0) % 2) - 0.5F) * this.width * 0.8F;
+		//            float var3 = ((float)((var1 >> 1) % 2) - 0.5F) * 0.1F;
+		//            float var4 = ((float)((var1 >> 2) % 2) - 0.5F) * this.width * 0.8F;
+	
+		Vec3d campos = getCameraBlock();
+	
+		//            int var5 = MathHelper.floor_double(this.posX + (double)var2);
+		//            //VIVE Crawling experiemnt
+		//            int var6 = MathHelper.floor_double(this.boundingBox.minY + (double)this.height + (double)var3);
+		//            //END VIVE
+		//            int var7 = MathHelper.floor_double(this.posZ + (double)var4);
+	
+		if ( this.mc.thePlayer.worldObj.getBlock((int)campos.xCoord, (int)campos.yCoord, (int)campos.zCoord).isNormalCube())
+		{
+			return true;
+		}
+	
+		//    }
+	
+		return false;
+	}
+
+	public void renderCrosshairAtDepth()
+	{
+		//Draw crosshair
+		boolean renderCrosshair = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+				(this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.vrSettings.hideGui);
+		
+		// VIVE start - don't render crosshair while teleporting
+		if (mc.vrPlayer.movementTeleportProgress>0.0f)
+		{
+			renderCrosshair = false;
+		}
+		// VIVE end
+		
+		if( this.mc.currentScreen == null && this.mc.gameSettings.thirdPersonView == 0 && renderCrosshair && !MCOpenVR.keyboardShowing && !mc.bowTracker.isDrawing)
+		{
+			this.mc.mcProfiler.endStartSection("crosshair");
+			GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+			float crossDepth =(float)crossVec.subtract(mc.roomScale.getControllerMainPos_World()).lengthVector();
+			if (crossDepth > MAX_CROSSHAIR_DISTANCE) crossDepth = MAX_CROSSHAIR_DISTANCE;
+			float depthscale = 0.4f + 0.6f*( (MAX_CROSSHAIR_DISTANCE - crossDepth) / MAX_CROSSHAIR_DISTANCE);
+			float scale = (float) (0.15f* this.mc.vrSettings.crosshairScale * Math.sqrt(mc.vrSettings.vrWorldScale));
+			scale/=(depthscale);
+			GL11.glPushMatrix();
+				GL11.glTranslatef(crossX, crossY, crossZ);
+				GL11.glRotatef(mc.vrPlayer.getControllerMainYaw_World(), 0.0F, 1.0F, 0.0F);
+				GL11.glRotatef(-mc.roomScale.getControllerMainPitch_World(), 1.0F, 0.0F, 0.0F);
+				if (this.mc.vrSettings.crosshairRollsWithHead)
+					GL11.glRotated(this.cameraRoll, 0.0F, 0.0F, 1.0F);
+				if (this.mc.vrSettings.crosshairScalesWithDistance)
+				{
+					// VIVE START - adjust depth scaling to handle far crosshair positions
+					scale = -0.05f;
+					GL11.glScalef(scale, scale, scale); // VIVE
+					// VIVE END - adjust depth scaling to handle far crosshair positions
+				}
+				else
+					GL11.glScalef(-scale, -scale, scale);
+				GL11.glDisable(GL11.GL_LIGHTING);
+				
+				if (!this.mc.vrSettings.useCrosshairOcclusion)	GL11.glDisable(GL11.GL_DEPTH_TEST);
+				GL11.glEnable(GL11.GL_BLEND);
+				
+				GL11.glBlendFunc(GL11.GL_ONE_MINUS_DST_COLOR, GL11.GL_ONE_MINUS_SRC_COLOR);
+								
+				if (mc.objectMouseOver == null) {
+	
+					
+					GL11.glRotatef(45, 0, 0, 1);
+				}
+				
+				this.mc.getTextureManager().bindTexture(Gui.icons);
+				
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+	
+				float var7 = 0.00390625F;
+				float var8 = 0.00390625F;
+//				Tessellator.instance.startDrawingQuads();
+//				Tessellator.instance.addVertexWithUV(- 1, + 1, 0,  0     , 15* var8);
+//				Tessellator.instance.addVertexWithUV(+ 1, + 1, 0, 15*var7, 15* var8);
+//				Tessellator.instance.addVertexWithUV(+ 1, - 1, 0, 15*var7, 0       );
+//				Tessellator.instance.addVertexWithUV(- 1, - 1, 0, 0      , 0       );
+//				Tessellator.instance.draw();
+				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+				GL11.glDisable(GL11.GL_BLEND);
+				GL11.glEnable(GL11.GL_DEPTH_TEST);
+				GL11.glColor4f(1, 1, 1, 1);
+			GL11.glPopMatrix();
+		}
+	
+	
+	}
+
+	public void renderFadeBlend(Color rgb, float fadeAlpha)
+	{
+		renderFadeBlend(rgb, fadeAlpha, 0, this.mc.displayWidth, this.mc.displayHeight, 0);
+	}
+
+	public void renderFadeEffects()
+	{
+		//        float overallFade = 0f;
+		//        Color3f rgb = new Color3f(0f, 0f, 0f);
+		//
+		//        // Determine pos track based fade
+		//        float posTrackFade = 0f;
+		//        if (this.mc.theWorld != null && this.mc.vrSettings.posTrackBlankOnCollision == true)
+		//        {
+		//            if (this.headCollision)
+		//            {
+		//                posTrackFade = 1f;
+		//                //this.mc.printChatMessage("Collision");
+		//            }
+		//            else if (this.headCollisionDistance != -1f && this.headCollisionDistance < this.headCollisionThresholdDistance)
+		//            {
+		//                posTrackFade = 1f - ((1f / this.headCollisionThresholdDistance) * this.headCollisionDistance);
+		//                //this.mc.printChatMessage("Collision in " + fadeBlend);
+		//            }
+		//            //else
+		//             //this.mc.printChatMessage("No collision");
+		//        }
+		//
+		//        float vrComfortFade = 0f;
+		//        if (this.mc.theWorld != null && this.mc.lookaimController != null && this.mc.vrSettings.useVrComfort != VRSettings.VR_COMFORT_OFF)
+		//        {
+		//            float yawRatchet = (float)this.mc.lookaimController.ratchetingYawTransitionPercent();
+		//            float pitchRatchet = (float)this.mc.lookaimController.ratchetingPitchTransitionPercent();
+		//
+		//            if (this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_BLANK)
+		//            {
+		//                if (yawRatchet > -1f || pitchRatchet > -1f)
+		//                {
+		//                    vrComfortFade = 1f;
+		//                }
+		//            }
+		//            else if(this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_FADE)
+		//            {
+		//                if (yawRatchet > -1f || pitchRatchet > -1f)
+		//                {
+		//                    vrComfortFade = Math.max(yawRatchet, pitchRatchet);
+		//                    if (vrComfortFade < 40f)
+		//                    {
+		//                        vrComfortFade = (vrComfortFade / 40f);
+		//                    }
+		//                    else if (vrComfortFade > 60f)
+		//                    {
+		//                        vrComfortFade = ((100f - vrComfortFade) / 40f);
+		//                    }
+		//                    else
+		//                    {
+		//                        vrComfortFade = 1f;
+		//                    }
+		//                }
+		//            }
+		//        }
+		//
+		//        overallFade = Math.max(posTrackFade, vrComfortFade);
+		//
+		//        if (overallFade > 0f)
+		//            renderFadeBlend(rgb, overallFade);
+	}
+	
+    //this is we dont have to change the signature of renderiteminfirstperson
+    public void renderItemInFirstPersonForController(float nano, int controller, ItemStack item){ //controller relative
+    	ItemRenderer e = this.itemRenderer;
+    	ItemStack prev = e.itemToRender;
+    	int preci = e.controller;
+    	e.itemToRender = item;
+    	e.controller = controller;
+    	e.renderItemInFirstPerson(nano);
+    	e.itemToRender = prev;
+    	e.controller = preci;
+    }
+	// VIVE END - render functions
+    
 }
