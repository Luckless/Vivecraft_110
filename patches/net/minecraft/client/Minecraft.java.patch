--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -13,10 +13,32 @@
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mtbs3d.minecrift.api.ErrorHelper;
+import com.mtbs3d.minecrift.api.IRoomscaleAdapter;
+import com.mtbs3d.minecrift.api.IStereoProvider;
+import com.mtbs3d.minecrift.gameplay.BowTracker;
+import com.mtbs3d.minecrift.gameplay.entityCameraEye;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.provider.OpenVRPlayer;
+import com.mtbs3d.minecrift.provider.OpenVRStereoRenderer;
+import com.mtbs3d.minecrift.render.FBOParams;
+import com.mtbs3d.minecrift.render.RenderConfigException;
+import com.mtbs3d.minecrift.render.ShaderHelper;
+import com.mtbs3d.minecrift.settings.VRHotkeys;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.TextureSelector;
+
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.FovPort;
+import de.fruitfly.ovr.structs.GLConfig;
+import de.fruitfly.ovr.structs.Sizei;
+
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
@@ -25,8 +47,11 @@
 import java.text.DecimalFormat;
 import java.text.MessageFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
@@ -42,6 +67,7 @@
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
@@ -112,12 +138,14 @@
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLeashKnot;
 import net.minecraft.entity.EntityList;
+import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.item.EntityArmorStand;
 import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.item.EntityEnderCrystal;
@@ -174,6 +202,7 @@
 import net.minecraft.util.text.Style;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.util.text.TextFormatting;
+import net.minecraft.world.DimensionType;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldProviderHell;
@@ -187,13 +216,19 @@
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
+import org.lwjgl.LWJGLUtil;
 import org.lwjgl.Sys;
+import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
+import org.lwjgl.opengl.ARBShaderObjects;
 import org.lwjgl.opengl.ContextCapabilities;
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.DisplayMode;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.opengl.OpenGLException;
 import org.lwjgl.opengl.PixelFormat;
@@ -201,6 +236,115 @@
 
 public class Minecraft implements IThreadListener, ISnooperInfo
 {
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer; 
+	public IRoomscaleAdapter roomScale;
+	public BowTracker bowTracker = new BowTracker(); 
+	
+	// VIVE END - teleport movement
+
+	// VIVE START - vive ui debugging
+	public float guiU;
+	public float guiV;
+	public float intersectDist;
+	public float pointOnPlaneX;
+	public float pointOnPlaneY;
+	public float pointOnPlaneZ;
+	public float guiTopLeftX;
+	public float guiTopLeftY;
+	public float guiTopLeftZ;
+	public float guiTopRightX;
+	public float guiTopRightY;
+	public float guiTopRightZ;
+	public float controllerPosX;
+	public float controllerPosY;
+	public float controllerPosZ;
+	// VIVE END - vive ui debugging
+	
+	/** MINECRIFT */
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float)(Math.PI/180);
+	public boolean reinitFramebuffers = true;
+	
+	private Framebuffer framebuffer;
+	private Framebuffer framebufferEye;
+	public Framebuffer guiFramebuffer = null;
+	
+	public int lastDisplayFBWidth = 0;
+	public int lastDisplayFBHeight = 0;
+	public int displayFBWidth;     /* Actual width of the display buffer */
+	public int displayFBHeight;    /* Actual height of the display buffer */
+	public int mirrorFBWidth;     /* Actual width of the display buffer */
+	public int mirrorFBHeight;    /* Actual height of the display buffer */
+	public int viewPortCount = 2;
+	public ShaderGroup shaderGroup;
+	public int lastShaderIndex = -1;
+	public Object displayImpl = null;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public IStereoProvider stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+	public boolean lastEnableVsync = true;
+	public int lastMirrorSetting = -1;
+	//public EyeRenderParams eyeRenderParams = null;
+	public EyeType currentEye = EyeType.ovrEye_Left;
+	public entityCameraEye eveLeftEye, rveRightEye;
+	public Cursor nativeMouseCursor = null;
+	public boolean lastShowMouseNative = true;
+	public Cursor invisibleMouseCursor = null;
+	public GLConfig glConfig = new GLConfig();
+	public long lastWindow = 0;
+	public int lastRenderDistanceChunks = -1;
+	public boolean lastFogFancy = true;
+	public boolean lastFogFast = false;
+	public float lastWorldScale = 0f;
+	public DimensionType lastDimensionId = DimensionType.OVERWORLD;
+	public SoundManager sndManager = null;
+	public boolean hydraLibsAvailable = false;
+	public double PredictedDisplayTimeSeconds = 0d;
+	public int _Lanczos_shaderProgramId = -1;
+	public int _LanczosShader_texelWidthOffsetUniform = -1;
+	public int _LanczosShader_texelHeightOffsetUniform = -1;
+	public int _LanczosShader_inputImageTextureUniform = -1;
+	private FBOParams mirrorFB = null;
+	private FBOParams fsaaFirstPassResultFBO;
+	private FBOParams fsaaSecondPassResultFBO;
+	private final float OCULUS_RED_COLOUR_COMPONENT = (1f/255f)*61f;
+	private final float OCULUS_GREEN_COLOUR_COMPONENT = (1f/255f)*61f;
+	private final float OCULUS_BLUE_COLOUR_COMPONENT = (1f/255f)*61f;
+	public float RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+	public float GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+	public float BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	private int lastGuiScale = -1;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	private TextureSelector renderTexProvider;
+	private TextureSelector mirrorTexProvider;
+	public boolean visible = true;
+	public ErrorHelper errorHelper;
+	public static final String RENDER_SETUP_FAILURE_MESSAGE = "Failed to initialise stereo rendering plugin: ";
+	public static final int ERROR_DISPLAY_TIME_SECS = 10;
+
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do not modify here.
+	 * Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "ViveCraft 1.10 Vivecraft-jrbudda1alpha";
+	/* end version */
+	/** END MINECRIFT */
+    
     private static final Logger LOGGER = LogManager.getLogger();
     private static final ResourceLocation LOCATION_MOJANG_PNG = new ResourceLocation("textures/gui/title/mojang.png");
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.EnumOS.OSX;
@@ -216,7 +360,7 @@
     private ServerData currentServerData;
 
     /** The RenderEngine instance used by Minecraft */
-    private TextureManager renderEngine;
+    public TextureManager renderEngine; //VIVECRAFT MAKE PUBLIC
 
     /**
      * Set to 'this' in Minecraft constructor; used by some settings get methods
@@ -349,7 +493,9 @@
     private ItemColors itemColors;
     private Framebuffer framebufferMc;
     private TextureMap textureMapBlocks;
-    private SoundHandler mcSoundHandler;
+	/** MINECRIFT */
+	public  SoundHandler mcSoundHandler; 
+	/** END MINECRIFT */
     private MusicTicker mcMusicTicker;
     private ResourceLocation mojangLogo;
     private final MinecraftSessionService sessionService;
@@ -1048,7 +1194,8 @@
     /**
      * Checks for an OpenGL error. If there is one, prints the error ID and error string.
      */
-    private void checkGLError(String message)
+    //VIVECRAFT MAKE public
+    public void checkGLError(String message)
     {
         int i = GlStateManager.glGetError();
 
@@ -1576,11 +1723,11 @@
     }
 
     @SuppressWarnings("incomplete-switch")
+	public //VIVECRAFT MAKE PUBLIC
 
     /**
      * Called when user clicked he's mouse right button (place)
-     */
-    private void rightClickMouse()
+     */ void rightClickMouse()
     {
         if (!this.playerController.getIsHittingBlock())
         {
@@ -2458,6 +2605,9 @@
      */
     public void loadWorld(WorldClient worldClientIn)
     {
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0, true);
+		// VIVE END - reset room origin
         this.loadWorld(worldClientIn, "");
     }
 
@@ -2623,7 +2773,7 @@
     /**
      * Called when user clicked he's mouse middle button (pick block)
      */
-    private void middleClickMouse()
+    public void middleClickMouse() //VIVECRAFT PUBLIC
     {
         if (this.objectMouseOver != null && this.objectMouseOver.typeOfHit != RayTraceResult.Type.MISS)
         {
@@ -3414,4 +3564,1062 @@
     {
         return this.thePlayer != null && this.thePlayer.hasReducedDebug() || this.gameSettings.reducedDebugInfo;
     }
+    
+    //VIVECRAFT ADDITIONS **************************************************************************
+    
+	private boolean renderSingleView(int eye, long nanoTime) {
+		boolean shouldupdate;
+			int x = GL11.glGetInteger(GL11.GL_MODELVIEW_STACK_DEPTH);				
+			while (x >1){
+				GL11.glPopMatrix(); ///WHO.. WHY??? Find this.
+				x = GL11.glGetInteger(GL11.GL_MODELVIEW_STACK_DEPTH);	
+			}
+			clearGLError();
+			
+			this.framebufferMc.bindFramebuffer(true);	//draw to eye texture.
+			
+			this.currentEye = this.stereoProvider.eyeRenderOrder(eye);
+
+			this.stereoProvider.setCurrentRenderTextureInfo(
+					this.currentEye.value(),
+					renderTexProvider.getCurrentSwapIdx(),
+					this.framebufferMc.depthBuffer,
+					this.framebufferMc.framebufferTextureWidth,
+					this.framebufferMc.framebufferTextureHeight); //just returns true
+			
+
+			if (this.entityRenderer != null)
+			{
+				this.entityRenderer.renderpass = eye;
+				this.entityRenderer.theShaderGroup = shaderGroup;
+			}
+
+			GL11.glPushMatrix();
+			GL11.glClearColor(0f, 0, 0, 1f);	
+			GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+								
+				GL11.glEnable(GL11.GL_TEXTURE_2D);
+				if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
+				{
+					this.gameSettings.thirdPersonView = 0;
+				}
+		
+				// Update our orientation and position variables from the sensor polled data
+				this.entityRenderer.updatePositionAndOrientation(this.timer.renderPartialTicks, Display.isActive());
+				
+				if (!this.skipRenderWorld)
+				{
+					this.mcProfiler.startSection("updateCameraAndRender:" + currentEye.ordinal());
+						///THIS IS WHERE EVERYTHING IS RENDERED
+						this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks,nanoTime);
+					this.mcProfiler.endSection();
+				}
+
+
+			this.mcProfiler.startSection("postProcessing:" + currentEye.ordinal());
+				GL11.glPushMatrix();
+				 	doPostProcessing(frameIndex, this.currentEye);
+				GL11.glPopMatrix();
+			this.mcProfiler.endSection();
+			
+			GL11.glPushMatrix();
+				//this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);   // <-- TODO: What does this do? Some sort of stream status overlay? REENABLE, move to GUI FBO?
+			GL11.glPopMatrix();
+							
+			framebufferEye.bindFramebuffer(true); //draw to eye tex
+			framebuffer.framebufferRender(framebufferEye.framebufferWidth, framebufferEye.framebufferHeight);
+			
+			this.mcProfiler.startSection("OpenGL Finish:" + currentEye.ordinal());
+			//	GL11.glFinish();
+			this.mcProfiler.endSection();
+			
+			this.mcProfiler.startSection("compositorSubmit:" + currentEye.ordinal());
+				if(this.stereoProvider.isStereo())
+					this.stereoProvider.endFrame(this.currentEye);
+				else
+					this.stereoProvider.endFrame();
+			this.mcProfiler.endSection();
+				
+			this.mcProfiler.startSection("Mirror:" + currentEye.ordinal());
+				shouldupdate =	copyToMirror(this.currentEye);
+			this.mcProfiler.endSection();
+			
+			x = GL11.glGetInteger(GL11.GL_MODELVIEW_STACK_DEPTH);
+			if(x>1)GL11.glPopMatrix(); ///WHO.. WHY??? Find this.
+			x = GL11.glGetInteger(GL11.GL_MODELVIEW_STACK_DEPTH);
+			if(x>1)GL11.glPopMatrix(); ///WHO.. WHY??? Find this.
+			clearGLError();
+			
+		return shouldupdate;
+	}
+
+    
+	public void printChatMessage(String msg)
+	{
+		if (this.theWorld != null) {
+			ITextComponent chatText = new TextComponentString(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+    
+	public void clearGLError() //bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+
+	private boolean copyToMirror(EyeType eye)
+	{
+		// VIVE start - render eye buffers to the desktop window
+
+		if (this.stereoProvider.isStereo() )
+		{
+			if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_OFF &&  this.vrPlayer.isHMDTracking()){
+				return false;
+			}else {
+				int every = 1;
+				int ports = 2;
+
+				if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_FULL_FRAME_RATE){
+					//ok
+				} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_FULL_FRAME_RATE_SINGLE_VIEW){
+					ports = 1;
+				}if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE){
+					every = 3;
+				}if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE_SINGLE_VIEW){
+					every = 3;
+					ports = 1;
+				}
+
+				if(ports == 2 || eye == EyeType.ovrEye_Right){
+					if((frameIndex % every) == 0){
+
+						int i = eye == EyeType.ovrEye_Left ? 0 : 1;
+						if(ports==1) i = 0;
+						
+						float phase = (getSystemTime() % 1000) / 1000.0f;
+						this.framebufferMc.unbindFramebuffer();	//draw directly to window
+						framebuffer.framebufferRender((int)(0 + (displayWidth *i)*0.5f),
+							displayWidth/ports, displayHeight,0 );
+
+						return true;
+					}
+				}
+			}
+		} else { //mono
+			this.framebufferMc.unbindFramebuffer();	//draw directly to window
+			framebuffer.framebufferRender(displayWidth, displayHeight);
+			return true;
+		}
+
+		return false;
+	}
+
+	private void setupRenderConfiguration() throws Exception 
+	{
+		boolean changeNonDestructiveRenderConfig = false;
+
+		glConfig.mirrorDisplay = this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF ? false : true;
+		glConfig.usePositionalTimewarp = this.vrSettings.usePositionalTimewarp;
+	
+		if (clipPlanesChanged())
+		{
+			this.reinitFramebuffers = true;
+		}
+
+		if (!Display.isActive() && this.fullscreen)
+		{
+			this.toggleFullscreen();
+			this.reinitFramebuffers = true;
+		}
+
+		if (wasDisplayResized())
+		{
+			Display.update();     // This will set new display widths accordingly
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.lastGuiScale != this.gameSettings.guiScale)
+		{
+			this.lastGuiScale = this.gameSettings.guiScale;
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.stereoProvider.isStereo()) {
+			showNativeMouseCursor(!Display.isActive());
+		}
+		else {
+			showNativeMouseCursor(true);
+		}
+
+		// Check for changes in window handle
+		glConfig = getLWJGLConfig(glConfig);
+		if (glConfig.Window != lastWindow)
+		{
+			this.reinitFramebuffers = true;
+			lastWindow = glConfig.Window;
+		}
+
+		if (lastShaderIndex != this.vrSettings.shaderIndex) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (lastMirrorSetting != this.vrSettings.displayMirrorMode) {
+			this.reinitFramebuffers = true;
+			lastMirrorSetting = this.vrSettings.displayMirrorMode;
+		}
+
+		if (this.lastEnableVsync != this.gameSettings.enableVsync) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.reinitFramebuffers)
+		{
+			this.visible = true;
+			this.checkGLError("Start Init");
+
+			viewPortCount = 1;
+
+			displayFBWidth = (Display.getWidth() < 1) ? 1 : Display.getWidth();
+			displayFBHeight = (Display.getHeight() < 1) ? 1 : Display.getHeight();
+				
+			Sizei EyeTextureSize = new Sizei(); 
+			
+			EyeTextureSize.w = this.displayWidth = displayFBWidth;
+			EyeTextureSize.h = this.displayHeight = displayFBHeight ;
+
+			FovPort leftFov = null;
+			FovPort rightFov = null;
+
+			if (!this.stereoProvider.isInitialized()) {
+				throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), " " + this.stereoProvider.isInitialized());
+			}
+
+			// Scale up the FBO to allow for the distortion
+			if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+			{
+//				leftFov = hmdInfo.getHMDInfo().DefaultEyeFov[0];
+//				rightFov = hmdInfo.getHMDInfo().DefaultEyeFov[1];
+
+//				System.out.println("L Fov:           " + leftFov.toString());
+//				System.out.println("R Fov:           " + rightFov.toString());
+
+				RenderTextureInfo renderTextureInfo = this.stereoProvider.getRenderTextureSizes(this.vrSettings.renderScaleFactor);
+
+				EyeTextureSize.w  = renderTextureInfo.LeftFovTextureResolution.w ;
+				EyeTextureSize.h  = renderTextureInfo.LeftFovTextureResolution.h ;
+
+				viewPortCount = 2;
+
+			}
+
+			if (this.framebuffer != null) {
+				this.framebuffer.deleteFramebuffer();
+				this.framebuffer = null;
+			}
+
+			if (this.framebufferEye != null) {
+				this.framebufferEye.deleteFramebuffer();
+				this.framebufferEye = null;
+			}
+			
+			this.stereoProvider.deleteRenderTextures(); ///TODO should this do something.. ?
+
+			if (this.guiFramebuffer != null) {
+				this.guiFramebuffer.deleteFramebuffer();
+				this.guiFramebuffer = null;
+			}
+
+			if (this.loadingScreen != null) {
+				this.loadingScreen.deleteFramebuffer();
+			}
+
+			if (this.mirrorFB != null) {
+				this.mirrorFB.delete();
+				this.mirrorFB = null;
+			}
+
+			this.stereoProvider.deleteMirrorTexture(); 
+
+			if (this.fsaaFirstPassResultFBO != null) {
+				this.fsaaFirstPassResultFBO.delete();
+				this.fsaaFirstPassResultFBO = null;
+			}
+
+			if (this.fsaaSecondPassResultFBO != null) {
+				this.fsaaSecondPassResultFBO.delete();
+				this.fsaaSecondPassResultFBO = null;
+			}
+
+
+			_LanczosShader_texelWidthOffsetUniform = -1;
+			_LanczosShader_texelHeightOffsetUniform = -1;
+			_LanczosShader_inputImageTextureUniform = -1;
+
+			int multiSampleCount = 0;
+			boolean multiSample = (multiSampleCount > 0 ? true : false);
+			
+
+			if (this.stereoProvider.providesMirrorTexture() && this.vrSettings.displayMirrorMode != VRSettings.MIRROR_OFF)
+			{ //alwasy false
+				this.mirrorFBWidth = this.displayFBWidth;
+				this.mirrorFBHeight = this.displayFBHeight;
+				if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_FULL_FRAME_RATE_SINGLE_VIEW ||
+						this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE_SINGLE_VIEW) {
+					this.mirrorFBWidth *= 2;
+					this.mirrorFBHeight *= 2;
+				}
+				int mirrorTextureId = this.stereoProvider.createMirrorTexture(this.mirrorFBWidth, this.mirrorFBHeight);
+				if (mirrorTextureId == -1) {
+					throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+				}
+				print("Provider supplied mirror texture ID: " + mirrorTextureId);
+
+				mirrorTexProvider.setTextureId(mirrorTextureId);
+				mirrorFB = new FBOParams("Mirror FBO", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, this.mirrorFBWidth, this.mirrorFBHeight, mirrorTexProvider);
+				System.out.println(mirrorFB.toString());
+			}
+			this.checkGLError("Mirror framebuffer setup");
+
+			if (this.stereoProvider.providesRenderTextures())
+			{ //always true
+				// Source render textures
+				RenderTextureSet renderTextures = this.stereoProvider.createRenderTexture(
+						EyeTextureSize.w,
+						EyeTextureSize.h);
+				if (renderTextures == null) {
+					throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+				}
+				print("L Render texture resolution: " + EyeTextureSize.w + " x " + EyeTextureSize.h);
+				print("Provider supplied render texture IDs:\n" + renderTextures.toString());
+
+				renderTexProvider.setTextureIds(renderTextures.leftEyeTextureIds);
+			}
+			else
+			{
+				// Generate our textures
+				renderTexProvider.genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, EyeTextureSize.w, EyeTextureSize.h, 1);
+			}
+			this.checkGLError("Render Texture setup");
+
+
+			this.framebufferEye = new Framebuffer(EyeTextureSize.w, EyeTextureSize.h, true);
+			print(this.framebufferEye.toString());
+			this.checkGLError("Left Eye framebuffer setup");
+			
+			this.displayFBWidth = (int) Math.ceil(EyeTextureSize.w * this.vrSettings.renderScaleFactor);
+			this.displayFBHeight = (int) Math.ceil(EyeTextureSize.h * this.vrSettings.renderScaleFactor);
+			
+			this.framebuffer = new Framebuffer(displayFBWidth , displayFBHeight, true);
+			print(this.framebuffer.toString());
+			this.checkGLError("3D framebuffer setup");
+			
+			this.guiFramebuffer  = new Framebuffer( this.displayWidth, this.displayHeight, true);
+			print(this.guiFramebuffer.toString());
+			this.checkGLError("GUI framebuffer setup");
+
+			this.framebuffer.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+			this.framebufferEye.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+			this.guiFramebuffer.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+
+		//	this.framebufferEye.bindfr;	//attaches the rendertexprovider's texture to the fbo
+			
+			this.entityRenderer.setupClipPlanes();
+
+			if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+			{
+				this.entityRenderer.eyeproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getProjectionMatrix(null, EyeType.ovrEye_Left, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance).transposed().toFloatBuffer();
+				this.entityRenderer.eyeproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getProjectionMatrix(null, EyeType.ovrEye_Right, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance).transposed().toFloatBuffer();
+			}
+
+			try
+			{
+				if (this.vrSettings.useFsaa)
+				{
+					// GL21.GL_SRGB8_ALPHA8
+					// GL11.GL_RGBA8
+
+					// Lanczos downsample FBOs
+					fsaaFirstPassResultFBO = new FBOParams("FSAA Pass1 FBO1 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, EyeTextureSize.w, displayFBHeight, null);
+					fsaaSecondPassResultFBO = new FBOParams("FSAA Pass2 FBO1", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, EyeTextureSize.w, EyeTextureSize.h, renderTexProvider);
+
+					print(this.fsaaFirstPassResultFBO.toString());
+					print(this.fsaaSecondPassResultFBO.toString());
+					checkGLError("FSAA FBO creation");
+
+					_Lanczos_shaderProgramId = ShaderHelper.initShaders(LANCZOS_SAMPLER_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER, true);
+					if (_Lanczos_shaderProgramId == 0) {
+						throw new Exception("Failed to validate FSAA shader!");
+					}
+
+					ShaderHelper.checkGLError("@1");
+
+					// Setup uniform IDs
+					_LanczosShader_texelWidthOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset");
+					_LanczosShader_texelHeightOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset");
+					_LanczosShader_inputImageTextureUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture");
+
+					ShaderHelper.checkGLError("FBO init Lanczos shader");
+				}
+			}
+			catch (Exception ex)
+			{
+				// We had an issue. Set the usual suspects to defaults...
+				this.vrSettings.useFsaa = false;
+				this.vrSettings.fsaaScaleFactor = 1.4f;
+				this.vrSettings.saveOptions();
+				System.out.println("[Minecrift] FAILED to setup FSAA: " + ex.getMessage());
+				reinitFramebuffers = true;
+				return;
+			}
+
+			// Init screen size
+			if (this.currentScreen != null)
+			{
+				ScaledResolution scaledresolution = new ScaledResolution(this);
+				int k = scaledresolution.getScaledWidth();
+				int l = scaledresolution.getScaledHeight();
+				this.currentScreen.setWorldAndResolution(this, k, l);
+			}
+			this.loadingScreen = new LoadingScreenRenderer(this, this.displayWidth, this.displayHeight);
+			this.loadingScreen.deleteFramebuffer();
+			this.loadingScreen.renderTarget = this.guiFramebuffer;
+
+			System.out.println("[Minecrift] New render config:" +
+					"\nRender target width:  " + (this.stereoProvider.isStereo() ? EyeTextureSize.w + EyeTextureSize.w: this.displayWidth) +
+					", height: " + (this.stereoProvider.isStereo() ? Math.max(EyeTextureSize.h, EyeTextureSize.h) : this.displayHeight) +
+					(this.stereoProvider.isStereo() ? " [Render scale: " + this.vrSettings.renderScaleFactor + "]" : "") +
+					(this.vrSettings.useFsaa ? " [FSAA Scale: " + this.vrSettings.fsaaScaleFactor + "]" : "") +
+					"\nDisplay target width: " + this.displayFBWidth + ", height: " + displayFBHeight);
+
+			// Init shaders
+			if (this.entityRenderer != null) {
+				if (shaderGroup != null)
+					shaderGroup.deleteShaderGroup();
+
+				lastShaderIndex = this.vrSettings.shaderIndex;
+				shaderGroup = this.entityRenderer.initShaderGroup(framebuffer);
+			}
+
+			this.lastDisplayFBWidth = this.displayFBWidth;
+			this.lastDisplayFBHeight = this.displayFBHeight;
+			this.lastEnableVsync = this.gameSettings.enableVsync;
+			this.reinitFramebuffers = false;
+
+			if (this.firstInit)
+			{
+//				// Workaround for bad init of Oculus SDK
+//				this.firstInit = false;
+//				this.reinitFramebuffers = true;
+//				System.out.println("[Minecrift] Now re-init for Oculus SDK weirdness...");
+			}
+		}
+
+		if (changeNonDestructiveRenderConfig || this.reinitFramebuffers)
+		{
+			this.stereoProvider.configureRenderer(glConfig); //does nothing for Vive
+		}
+		
+	}
+
+	public void doStencilForEye(int i) {
+		this.framebuffer.bindFramebuffer(true);
+
+			//START STENCIL TESTING - Yes I know there's about 15 better ways to do this.
+			float[] verts = stereoProvider.getStencilMask(this.currentEye);
+			if(verts!=null){
+				GL11.glEnable(GL11.GL_STENCIL_TEST);
+				GL11.glDisable(GL11.GL_CULL_FACE);
+				GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_REPLACE);
+				GL11.glStencilMask(0xFF); // Write to stencil buffer
+				GL11.glClear(GL11.GL_STENCIL_BUFFER_BIT); // Clear stencil buffer (0 by default)
+				GL11.glStencilFunc(GL11.GL_ALWAYS, 0xFF, 0xFF); // Set any stencil to 1
+				GL11.glColor3f(0, 0, 0);
+				GL11.glDepthMask(false); // Don't write to depth buffer
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glLoadIdentity();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glLoadIdentity();
+				GL11.glOrtho(0.0D, displayFBWidth,displayFBHeight, 0.0D, -10, 20.0D);
+				GL11.glViewport(0, 0, displayFBWidth, displayFBHeight);
+
+				GL11.glBegin(GL11.GL_TRIANGLES);
+
+				for (int ix = 0;ix< verts.length;ix+=2) {
+					GL11.glVertex2f(verts[ix], verts[ix+1]);
+				}
+				GL11.glEnd();	
+
+				GL11.glStencilFunc(GL11.GL_NOTEQUAL, 0xFF, 1);
+				GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_KEEP);
+				GL11.glDepthMask(true); // Don't write to depth buffer
+				GL11.glEnable(GL11.GL_CULL_FACE);
+				GL11.glStencilMask(0x0); // Dont Write to stencil buffer
+				
+			}
+			/// END STENCIL TESTING
+	}
+
+	public boolean clipPlanesChanged()
+	{
+		boolean changed = false;
+
+		if (this.theWorld != null && this.theWorld.provider != null)
+		{
+			if (this.theWorld.provider.getDimensionType() != this.lastDimensionId)
+			{
+				//changed = true;   // TODO: Re-enable when Lib OVR doesn't crash all the bloody time. We
+				// can't currently change render config in-game, without a crash in
+				// nvgl.dll glDrawArrays
+			}
+		}
+
+//		if( this.gameSettings.renderDistanceChunks != this.lastRenderDistanceChunks ||
+//				Config.isFogFancy() != this.lastFogFancy                                ||
+//				Config.isFogFast() != this.lastFogFast)
+//		{
+//			changed = true;
+//		}
+
+		lastRenderDistanceChunks = this.gameSettings.renderDistanceChunks;
+//		lastFogFancy = Config.isFogFancy();
+//		lastFogFast = Config.isFogFast();
+		if (this.theWorld != null && this.theWorld.provider != null)
+			lastDimensionId = this.theWorld.provider.getDimensionType();
+
+		return changed;
+	}
+
+	public GLConfig getLWJGLConfig(GLConfig glConfig)
+	{
+		// TODO: For LWJGL 3.0, this function may well be screwed...
+
+		// We need to retrieve certain pointers / handles from LWJGL
+		// for the Oculus SDK. However, these are not exposed by
+		// LWJGL, so use reflection to get hold of the data we need.
+
+		try
+		{
+			switch(LWJGLUtil.getPlatform())
+			{
+			case LWJGLUtil.PLATFORM_WINDOWS:
+			{
+				// Get HWND pointer...
+				if (fieldHwnd == null)
+				{
+					fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+					fieldHwnd.setAccessible(true);
+				}
+				glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+				//System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_LINUX:
+			{
+				// Get Display and Window pointers...
+				if (fieldDisplay == null)
+				{
+					fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+					fieldDisplay.setAccessible(true);
+				}
+				if (fieldWindow == null)
+				{
+					fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+					fieldWindow.setAccessible(true);
+				}
+				glConfig.Display = (Long) fieldDisplay.get(null);
+				glConfig.Window = (Long) fieldWindow.get(null);
+				//System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+				//System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_MACOSX:
+			{
+				// Do nowt...
+				break;
+			}
+			default:
+				throw new Exception ("Current platform not supported!");
+			}
+		}
+		catch (Exception ex)
+		{
+			ex.printStackTrace();
+			glConfig = null;
+		}
+
+		return glConfig;
+	}
+
+	public boolean wasDisplayResized()
+	{
+		boolean wasResized = false;
+
+		// We don't want to have to call Display.update() just to determine
+		// if the display has been resized - this will invoke a swapBuffer.
+
+		switch(LWJGLUtil.getPlatform())
+		{
+		case LWJGLUtil.PLATFORM_WINDOWS:
+		case LWJGLUtil.PLATFORM_LINUX: {
+			// Get the 'resized' field from the Display class...
+			try {
+				if (fieldResized == null) {
+					fieldResized = displayImpl.getClass().getDeclaredField("resized");
+					fieldResized.setAccessible(true);
+				}
+				wasResized = (Boolean) fieldResized.get(displayImpl);
+			} catch (Exception e) {
+				System.out.println(displayImpl.getClass().getName());
+				e.printStackTrace();
+			}
+		}
+		break;
+		case LWJGLUtil.PLATFORM_MACOSX: {
+			// Get the 'wasResized' method from the Display class...
+			try {
+				if (fieldResizedMethod == null) {
+					fieldResizedMethod = displayImpl.getClass().getDeclaredMethod("wasResized");
+					fieldResizedMethod.setAccessible(true);
+				}
+				wasResized = (Boolean) fieldResizedMethod.invoke(displayImpl);
+			} catch (Exception e) {
+				System.out.println(displayImpl.getClass().getName());
+				e.printStackTrace();
+			}
+		}
+		break;
+		}
+
+		if (wasResized)
+			System.out.println("Display resized");
+
+		return wasResized;
+	}
+
+	public void initMinecrift() throws Exception
+	{
+		this.lastGuiScale = this.gameSettings.guiScale;
+
+		// Get underlying LWJGL Display implementation
+		if (displayImpl == null)
+		{
+			try {
+				Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+				displayMethod.setAccessible(true);
+				displayImpl = displayMethod.invoke(null, (java.lang.Object[])null); // VIVE fix warning
+				System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+		try {
+			//Class.forName("com.mtbs3d.minecrift.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+			//hydraLibsAvailable = true;
+		} catch (NoClassDefFoundError e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		} catch( Exception e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		}
+
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+		this.vrPlayer = new OpenVRPlayer();
+		this.roomScale = this.vrPlayer;
+		this.vrSettings.vrAllowCrawling = false;
+		//hmdInfo = PluginManager.configureHMD("oculus");
+
+		//TODO: init new steroerenderer
+
+		nativeMouseCursor = Mouse.getNativeCursor();
+		try {
+			invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+		} catch (LWJGLException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void showNativeMouseCursor(boolean show)
+	{
+		if (show == lastShowMouseNative)
+			return;
+
+		lastShowMouseNative = show;
+
+		try
+		{
+			if (show)
+			{
+				Mouse.setNativeCursor(nativeMouseCursor);
+			}
+			else
+			{
+				Mouse.setNativeCursor(invisibleMouseCursor);
+			}
+		}
+		catch (LWJGLException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+
+	public boolean endFrame()
+	{				
+		if (this.stereoProvider != null)
+			this.stereoProvider.endFrame();
+
+		return true;
+	}
+
+	public double getCurrentTimeSecs()
+	{
+		return this.stereoProvider.getCurrentTimeSecs();
+	}
+
+	private void doPostProcessing(long frameIndex, EyeType eye)
+	{
+			
+		// VIVE start - screen flash when hurt instead of view tilt
+		Entity player = renderViewEntity;
+		if (player!=null && player.getHealth() > 0.0f)
+		{
+			float var3 = (float)player.hurtTime - timer.renderPartialTicks;
+			if (var3>0.0f)
+			{
+				var3 /= (float) player.maxHurtTime;
+				var3 = MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+				final Color3f rgb = new Color3f(255.0f, 0f, 0f);
+				this.entityRenderer.renderFadeBlend(rgb, var3);
+			}
+		}
+		// VIVE end - screen flash when hurt instead of view tilt
+
+		if (showSplashScreen && splashFadeAlpha > 0)
+		{
+		//	final Color3f rgb = new Color3f(0f, 0f, 0f);
+		//	this.entityRenderer.renderFadeBlend(rgb, splashFadeAlpha);
+		}
+	
+		if (this.vrSettings.useFsaa )
+		{
+			if (this.fsaaFirstPassResultFBO == null){
+				this.reinitFramebuffers = true;
+				return;
+			} else {
+
+				GL11.glDisable(GL11.GL_ALPHA_TEST);
+				GL11.glDisable(GL11.GL_BLEND);
+
+				// Setup ortho projection
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glPushMatrix();
+					GL11.glLoadIdentity();
+					GL11.glMatrixMode(GL11.GL_MODELVIEW);
+					GL11.glPushMatrix();
+						GL11.glLoadIdentity();
+		
+						GL11.glTranslatef(0.0f, 0.0f, -.7f);
+						// Pass 1 - horizontal
+						// Now switch to 1st pass FSAA result target framebuffer
+						this.fsaaFirstPassResultFBO.bindRenderTarget();
+		
+						// Bind the FBO Texture
+						this.framebuffer.bindFramebufferTexture();
+		
+						GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+						GL11.glClearDepth(1.0D);
+						GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer
+		
+						// Render onto the entire screen framebuffer
+						GL11.glViewport(0, 0, fsaaFirstPassResultFBO.getFramebufferWidth(), fsaaFirstPassResultFBO.getFramebufferHeight());
+		
+						// Set the downsampling shader as in use
+						ARBShaderObjects.glUseProgramObjectARB(_Lanczos_shaderProgramId);
+		
+						// Set up the fragment shader uniforms
+						ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 1.0f / (3.0f * (float) fsaaFirstPassResultFBO.getFramebufferWidth()));
+						ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 0.0f);
+						ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+		
+						GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
+		
+						drawQuad();
+		
+						// checkGLError("After Lanczos Pass1");
+		
+						// Pass 2 - Vertial
+						// Now switch to 2nd pass screen framebuffer
+						fsaaSecondPassResultFBO.bindRenderTarget();
+						fsaaSecondPassResultFBO.selectTexture(); //this is our Eye tex!
+		
+						fsaaFirstPassResultFBO.bindTexture();
+		
+						GL11.glViewport(0, 0,fsaaSecondPassResultFBO.getFramebufferWidth(), fsaaSecondPassResultFBO.getFramebufferHeight());
+						GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+						GL11.glClearDepth(1.0D);
+						GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+		
+						// Bind the texture
+						GL13.glActiveTexture(GL13.GL_TEXTURE0);
+		
+						// Set up the fragment shader uniforms for pass 2
+						ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 0.0f);
+						ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 1.0f / (3.0f * (float) fsaaSecondPassResultFBO.getFramebufferHeight()));
+						ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+						
+						drawQuad();
+		
+						// Stop shader use
+						ARBShaderObjects.glUseProgramObjectARB(0);
+						// checkGLError("After Lanczos Pass2");
+		
+						GL11.glEnable(GL11.GL_ALPHA_TEST);
+						GL11.glEnable(GL11.GL_BLEND);
+
+						GL11.glPopMatrix();
+					GL11.glMatrixMode(GL11.GL_PROJECTION);
+					GL11.glPopMatrix();					
+			}
+		}
+	}
+
+	public void drawQuad()
+	{
+		// this func just draws a perfectly normal box with some texture coordinates
+		GL11.glBegin(GL11.GL_QUADS);
+
+		// Front Face
+		GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+	public void showSplash(Framebuffer rendertarget)
+	{
+
+//		final int SPLASH_TIMEOUT_MS = this.stereoProvider.isStereo() ? 2000 : 1500;
+//		final int SPLASH_FADE_TIMEOUT_MS = this.stereoProvider.isStereo() ? 1000 : 0;
+//		splashFadeAlpha = 0f;
+//		final long currentTimeMs = System.currentTimeMillis();
+//
+//		// Start display splash timer (only after any calibration has finished)
+//		if (splashTimer1 == 0 && splashTimer2 == 0)
+//		{
+//			splashTimer1 = currentTimeMs;
+//		}
+//
+//		RED_COLOUR_COMPONENT = 1f;
+//		GREEN_COLOUR_COMPONENT = 1f;
+//		BLUE_COLOUR_COMPONENT = 1f;
+//
+//		// Start fade timer
+//		if (splashTimer1 != 0 && (currentTimeMs > splashTimer1 + SPLASH_TIMEOUT_MS))
+//		{
+//			splashTimer1 = 0;
+//			splashTimer2 = currentTimeMs;
+//		}
+//
+//		// Continue or end fade
+//		if (splashTimer2 != 0 && (currentTimeMs < splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+//		{
+//			splashFadeAlpha = (100f / SPLASH_FADE_TIMEOUT_MS) * (currentTimeMs - splashTimer2) * 0.01f;
+//		}
+//		else if (splashTimer2 != 0 && (currentTimeMs >= splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+//		{
+//			this.showSplashScreen = false;
+//			splashFadeAlpha = this.stereoProvider.isStereo() ? 1f : 0f;
+//			RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+//			GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+//			BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+//		}
+//
+//		int existingScale = gameSettings.guiScale;
+//		gameSettings.guiScale = 0;
+//		ScaledResolution var1 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+//				int var2 = var1.getScaleFactor();
+//		splash = guiFramebuffer;
+//		GL11.glMatrixMode(GL11.GL_PROJECTION);
+//		GL11.glLoadIdentity();
+//		GL11.glOrtho(0.0D, (double) var1.getScaledWidth(), (double) var1.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);
+//		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//		GL11.glLoadIdentity();
+//		GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+//		GL11.glDisable(GL11.GL_LIGHTING);
+//		GL11.glDisable(GL11.GL_FOG);
+//		GL11.glDisable(GL11.GL_DEPTH_TEST);
+//		GL11.glEnable(GL11.GL_TEXTURE_2D);
+//			
+//		try
+//		{
+//			if (this.mojangLogo == null)
+//				this.mojangLogo = this.renderEngine.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(this.mcDefaultResourcePack.getInputStream(this.locationMojangPng))));
+//			this.renderEngine.bindTexture(this.mojangLogo);
+//		}
+//		catch (IOException var7)
+//		{
+//			logger.error("Unable to load logo: " + locationMojangPng, var7);
+//		}
+//
+//		Tessellator var4 = Tessellator.getInstance();
+//		var4.startDrawingQuads();
+//		var4.setColorOpaque_I(16777215);
+//		var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+//		var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+//		var4.addVertexWithUV((double) this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+//		var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+//		var4.draw();
+//		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+//		var4.setColorOpaque_I(16777215);
+//		short var5 = 256;
+//		short var6 = 256;
+//		this.scaledTessellator((var1.getScaledWidth() - var5) / 2, (var1.getScaledHeight() - var6) / 2, 0, 0, var5, var6);
+//		GL11.glDisable(GL11.GL_LIGHTING);
+//		GL11.glDisable(GL11.GL_FOG);
+//		rendertarget.bindFramebuffer(true);
+//		splash.framebufferRender(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2);
+//		GL11.glEnable(GL11.GL_ALPHA_TEST);
+//		GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+//		//GL11.glFlush();
+//		//Display.update();
+//		gameSettings.guiScale = existingScale;
+//		//this.func_147120_f();
+//		
+	}
+
+	private static void sleepNanos (long nanoDelay)
+	{
+		final long end = System.nanoTime() + nanoDelay;
+		do
+		{
+			Thread.yield();  // This is a busy wait sadly...
+		}
+		while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime)
+	{
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0)
+		{
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+		{
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++)
+			{
+				array[i] = (Long)itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos()
+	{
+		return medianRunTickTimeNanos;
+	}
+
+	public final String LANCZOS_SAMPLER_VERTEX_SHADER =
+			"#version 120\n" +
+					"\n" +
+					" uniform float texelWidthOffset;\n" +
+					" uniform float texelHeightOffset;\n" +
+					"\n" +
+					" varying vec2 centerTextureCoordinate;\n" +
+					" varying vec2 oneStepLeftTextureCoordinate;\n" +
+					" varying vec2 twoStepsLeftTextureCoordinate;\n" +
+					" varying vec2 threeStepsLeftTextureCoordinate;\n" +
+					" varying vec2 fourStepsLeftTextureCoordinate;\n" +
+					" varying vec2 oneStepRightTextureCoordinate;\n" +
+					" varying vec2 twoStepsRightTextureCoordinate;\n" +
+					" varying vec2 threeStepsRightTextureCoordinate;\n" +
+					" varying vec2 fourStepsRightTextureCoordinate;\n" +
+					"\n" +
+					" void main()\n" +
+					" {\n" +
+					"     gl_Position = ftransform();\n" +
+					"\n" +
+					"     vec2 firstOffset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+					"     vec2 secondOffset = vec2(2.0 * texelWidthOffset, 2.0 * texelHeightOffset);\n" +
+					"     vec2 thirdOffset = vec2(3.0 * texelWidthOffset, 3.0 * texelHeightOffset);\n" +
+					"     vec2 fourthOffset = vec2(4.0 * texelWidthOffset, 4.0 * texelHeightOffset);\n" +
+					"\n" +
+					"     vec2 textCoord = gl_MultiTexCoord0.xy;\n" +
+					"     centerTextureCoordinate = textCoord;\n" +
+					"     oneStepLeftTextureCoordinate = textCoord - firstOffset;\n" +
+					"     twoStepsLeftTextureCoordinate = textCoord - secondOffset;\n" +
+					"     threeStepsLeftTextureCoordinate = textCoord - thirdOffset;\n" +
+					"     fourStepsLeftTextureCoordinate = textCoord - fourthOffset;\n" +
+					"     oneStepRightTextureCoordinate = textCoord + firstOffset;\n" +
+					"     twoStepsRightTextureCoordinate = textCoord + secondOffset;\n" +
+					"     threeStepsRightTextureCoordinate = textCoord + thirdOffset;\n" +
+					"     fourStepsRightTextureCoordinate = textCoord + fourthOffset;\n" +
+					" }\n";
+
+	public final String LANCZOS_SAMPLER_FRAGMENT_SHADER =
+
+			"#version 120\n" +
+					"\n" +
+					" uniform sampler2D inputImageTexture;\n" +
+					"\n" +
+					" varying vec2 centerTextureCoordinate;\n" +
+					" varying vec2 oneStepLeftTextureCoordinate;\n" +
+					" varying vec2 twoStepsLeftTextureCoordinate;\n" +
+					" varying vec2 threeStepsLeftTextureCoordinate;\n" +
+					" varying vec2 fourStepsLeftTextureCoordinate;\n" +
+					" varying vec2 oneStepRightTextureCoordinate;\n" +
+					" varying vec2 twoStepsRightTextureCoordinate;\n" +
+					" varying vec2 threeStepsRightTextureCoordinate;\n" +
+					" varying vec2 fourStepsRightTextureCoordinate;\n" +
+					"\n" +
+					" // sinc(x) * sinc(x/a) = (a * sin(pi * x) * sin(pi * x / a)) / (pi^2 * x^2)\n" +
+					" // Assuming a Lanczos constant of 2.0, and scaling values to max out at x = +/- 1.5\n" +
+					"\n" +
+					" void main()\n" +
+					" {\n" +
+					"     vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.38026;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.27667;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.27667;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.08074;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, threeStepsRightTextureCoordinate) * -0.02612;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, fourStepsRightTextureCoordinate) * -0.02143;\n" +
+					"\n" +
+					"     gl_FragColor = fragmentColor;\n" +
+					" }\n";
+
+
+	public void triggerYawTransition(boolean isPositive) {
+	//	this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s)
+	{
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
 }
